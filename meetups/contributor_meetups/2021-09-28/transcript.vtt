WEBVTT

1
00:00:02.309 --> 00:00:06.780
Okay, uh, and so.

2
00:00:06.780 --> 00:00:07.230
So,

3
00:00:07.285 --> 00:00:09.445
after during all this time,

4
00:00:09.474 --> 00:00:09.804
uh,

5
00:00:09.835 --> 00:00:11.904
what happened was we also,

6
00:00:11.964 --> 00:00:12.205
uh,

7
00:00:12.324 --> 00:00:12.685
normal,

8
00:00:12.714 --> 00:00:18.445
primarily implemented and somewhat similar um,

9
00:00:18.504 --> 00:00:19.074
we could,

10
00:00:19.105 --> 00:00:19.405
uh,

11
00:00:19.464 --> 00:00:20.155
we had like,

12
00:00:20.155 --> 00:00:22.045
new APIs there we had learning.

13
00:00:22.045 --> 00:00:26.484
So we thought we should probably use those learnings if we were to do.

14
00:00:28.230 --> 00:00:39.149
In some cases, uh, some, uh, folks have also said, or reported that the child channel, there was the performance overhead.

15
00:00:39.149 --> 00:00:46.740
There's a lot of bootstrapping required to create channels so they, we thought that okay, uh, perhaps we should take this also as a point.

16
00:00:46.740 --> 00:00:50.219
Uh, and figuring out whether we can resolve this.

17
00:00:50.219 --> 00:00:54.929
Uh, other, uh, bits were that there was.

18
00:00:54.929 --> 00:00:59.189
And not a ton of visibility on the control frames. Um.

19
00:00:59.189 --> 00:01:10.140
Being exchanged on the, um, on the channel, uh, because like, we, it, it doesn't go through the entire pipeline. Um, so that we want to do improve essentially.

20
00:01:10.140 --> 00:01:15.239
There are few other things, which were kind of hampering for, like.

21
00:01:15.239 --> 00:01:30.144
Top level frameworks, um, are built on top of maybe an example of that, is that we, we tied close and go away. So so basically, we had to give, like, books to basically disable that. So, so learning from all that we wanted to make, like, more, uh.

22
00:01:30.420 --> 00:01:35.730
Open clickable so that framework scan built on top of the existing.

23
00:01:35.730 --> 00:01:43.109
Um, so that essentially like like the wise as to why we, uh, went on this, uh, essentially, uh.

24
00:01:43.284 --> 00:01:51.894
Work item to see what can change and the goal is kind of simple here. What we want to do is to create a single API.

25
00:01:52.075 --> 00:02:06.025
Uh, and our primary motivation is to provide, uh, uh, as close to, um, traditional APIs, which is channel based. So every stream will be a channel in the API that essentially is the goal.

26
00:02:06.329 --> 00:02:14.849
Uh, another like, experimental is, as I mentioned before about the child channel performance, uh, essentially, uh.

27
00:02:14.849 --> 00:02:22.110
When we are doing this API, our intent is to so figure it out, whether we can't do anything, uh, which can improve the performance in general.

28
00:02:22.110 --> 00:02:25.199
Reduce the overhead.

29
00:02:25.199 --> 00:02:29.009
Um, alright.

30
00:02:29.009 --> 00:02:35.789
Scott, I mean, like, I can't see the chat on my screen, so if there is something just please interrupt me anytime.

31
00:02:37.110 --> 00:02:42.990
Um, okay, yeah, there was 1 question for Moses. Okay. Okay. Yeah. Yeah.

32
00:02:42.990 --> 00:02:56.280
Would you want us to do? Yeah. Yeah. So my question was around the child channel performance issues and we've seen this a little too also from you is what you were saying. It sounded like it was bootstrapping problems. So the problem was around.

33
00:02:56.280 --> 00:03:01.680
Having to do set up and tear down for the channel on each screen. Yeah. Um.

34
00:03:01.680 --> 00:03:05.280
It's from white from the wave.

35
00:03:05.280 --> 00:03:11.669
It's currently described it sounds like the new API would also have that problem. So what are the kinds of experiments you're considering to alleviate.

36
00:03:12.504 --> 00:03:12.925
Yeah,

37
00:03:12.955 --> 00:03:13.675
good question I mean,

38
00:03:13.705 --> 00:03:14.125
uh,

39
00:03:14.215 --> 00:03:16.164
at this point what we have,

40
00:03:16.194 --> 00:03:16.585
uh,

41
00:03:16.615 --> 00:03:20.034
in the in the what it has is there is a concept of a raw channel,

42
00:03:20.245 --> 00:03:20.574
uh,

43
00:03:20.604 --> 00:03:23.544
which basically doesn't create channels channels but you can,

44
00:03:23.844 --> 00:03:27.264
you can use the basic channel as you would,

45
00:03:27.414 --> 00:03:29.395
in ready to pass frames.

46
00:03:29.425 --> 00:03:43.074
Uh, but that again is experimental that the 1st attempt uh, ideally, what we want to do here is once we have the channel channel setup, uh, we would like performance test and see, where are the bottlenecks to, to get the next steps going.

47
00:03:43.379 --> 00:03:46.979
But still like early stages so it's.

48
00:03:46.979 --> 00:03:58.530
Sorry, go ahead. I also hear, um, question about that. Uh, especially for quick where you again create channels, do you expect to have changes there?

49
00:04:00.419 --> 00:04:05.310
And go ahead. Yeah, and quick, I mean, quick is still like.

50
00:04:05.310 --> 00:04:10.530
Incubating so, I mean, there could definitely be changes. I think if we find.

51
00:04:10.530 --> 00:04:20.759
Good trade off to make, like, the general creation cheaper in the in a sense for, um, then we will probably do the same in the quick layer.

52
00:04:20.759 --> 00:04:28.319
I mean, we definitely have the same problem there as well at the moment. I mean, it's, it's not a big deal if you have, like, long living streams, but it's definitely.

53
00:04:28.319 --> 00:04:40.889
Bigger deal if it's like short living right? Because you, you need to create a channel, you register it. You, you know, like you populate the pipeline, send like, multiple events just to maybe get 1 frame.

54
00:04:40.889 --> 00:04:46.439
So, you may end up to have, like, 4 extra events just to get, like, 1 frame, which is a little bit.

55
00:04:47.579 --> 00:04:50.759
I would say, well, it's not really bad, but it's.

56
00:04:50.759 --> 00:04:59.158
It doesn't feel right in the, in the sense of, of, you know, like the balance between overhead and the abstraction.

57
00:04:59.158 --> 00:05:06.298
So maybe 1 thing we could do, but like, like you just said, it's probably a little bit earliest to try to, um.

58
00:05:06.298 --> 00:05:14.488
To combine events, for example, or something like this. I'm not sure about this. So, maybe make pipeline, like, setting up pipelines more cheaper than it is.

59
00:05:14.488 --> 00:05:24.778
At the moment, but I think whatever we find that works for is definitely the same that we would back port to to quick or the other way around.

60
00:05:26.459 --> 00:05:29.459
Um, I'll mention as far as the the.

61
00:05:29.459 --> 00:05:36.358
Problem okay, there it's going I'll mention as far as the problems that you listed. Some of those were not in the original.

62
00:05:36.358 --> 00:05:44.608
Pr that I started with HB, 2 stuff, it was introduced as we were trying to get.

63
00:05:44.608 --> 00:05:48.809
Performance up, and some things like that, like, there were.

64
00:05:50.213 --> 00:06:04.613
They were, they were choice decisions like like all the frames, uh, all the control frames. Don't necessarily pass. My my original implementation did pass them all, but we were fighting the performance issues.

65
00:06:05.004 --> 00:06:06.413
So, um.

66
00:06:06.959 --> 00:06:14.668
There's, there's some stuff here I see about maybe doing the child channel differently, but how.

67
00:06:14.668 --> 00:06:26.699
How could we end up passing all of those events back and forth and not be concerned about it? Where, before we were seeing object allocation overhead or other things come into play.

68
00:06:27.744 --> 00:06:42.413
No, it's, it's a good question. And again, again, like, this is, this is this is early days so I think we would, we would definitely learn and thanks for bringing that up that it was how it was and then, uh, we, uh, kind of changed it. So, I'm I'm totally in here to, uh.

69
00:06:44.244 --> 00:06:56.124
Change yes, we do. I think the advantage we have with 5.0 is like, we can take a hard look at the more core features. Like, what is the channel life cycle? How does initialization of the pipeline work?

70
00:06:56.124 --> 00:07:02.483
And, like, we know that there's some potential regression between these different APIs. However.

71
00:07:03.928 --> 00:07:09.988
The challenge channel API is much more true to Neti and allows you to reuse handlers, et cetera. So.

72
00:07:09.988 --> 00:07:19.829
We have a vested interest in, like, making that work and, you know, performance be as good as possible. So, um, yeah, I think there's work still to be had here, but we know.

73
00:07:19.829 --> 00:07:27.119
You know, we've seen it ourselves, um, in terms of the transition between the 2 APIs. Um, so an area of interest, I would say at this point.

74
00:07:27.119 --> 00:07:33.809
I will say 1 thing that made it harder to follow the PR, is that.

75
00:07:33.809 --> 00:07:41.519
Like, let's like that part about all the control flames frames don't pass, uh, between the, the child and the, the parents.

76
00:07:41.519 --> 00:07:44.819
Most applications really wouldn't notice that.

77
00:07:44.819 --> 00:07:49.499
Um, like, if we started passing them, that is sort of a change that we could maybe.

78
00:07:49.499 --> 00:08:00.178
Do without impacting very many people so basically we were talking about oh, let's change the API, but a lot of it actually seems more implementation level.

79
00:08:00.178 --> 00:08:03.389
So, it wasn't.

80
00:08:03.389 --> 00:08:16.858
It was requiring quite a bit of digging to sort of tease apart. What things are we trying to just improve in the implementation versus which things are more API level and will impact, uh, more callers.

81
00:08:19.379 --> 00:08:25.108
Okay, okay, I mean, hopefully like this discussion with Eric, uh, and, uh.

82
00:08:25.108 --> 00:08:28.798
Yeah, uh, they can, we can, we can call it out essentially.

83
00:08:28.798 --> 00:08:32.818
Um, cool. All right.

84
00:08:32.818 --> 00:08:44.609
Let's let's move on, uh, the next steps like that I have here are the next set of slides are essentially to go over the changes. The abstractions essentially. Um.

85
00:08:44.609 --> 00:08:54.839
So, again, like, for her who have not seen, uh, this is basically a PR that we are going over in this, um.

86
00:08:54.839 --> 00:09:03.599
In these slides, um, the 1st, thing that I would want to go over is like, how the channel is set up.

87
00:09:03.599 --> 00:09:12.749
Uh, this image I have copied it from the, from the PR side is a little pixelated, but I'll, I'll go over this, uh, these things that happen.

88
00:09:12.749 --> 00:09:20.729
Uh, so, at a, at a high level, um, we have, uh, we have 2 channels set up, or more than 1 channels that have 1, is the paid in channel.

89
00:09:20.729 --> 00:09:32.068
Which is social connection, and as in when, uh, new streams are set up on that connection, we create new channel, new channels per stream, including the control stream.

90
00:09:32.068 --> 00:09:39.239
Uh, and any new request stream that is, uh, established, we'll have a channel, uh, for it.

91
00:09:40.043 --> 00:09:54.833
Um, then, uh, we'll go as to how the messages, uh, flow essentially, uh, 1st, side is the read side. So read, uh, happens on the parent channel. Uh, and the thing that firstly comes up is the decoder.

92
00:09:55.374 --> 00:10:01.403
So, on the parent channel, we basically try to decode read frames and create an frame instance.

93
00:10:01.708 --> 00:10:06.178
Which, uh, goes ahead into, uh.

94
00:10:06.178 --> 00:10:13.528
The flow control handler, um, uh, uh, which basically reads the.

95
00:10:13.528 --> 00:10:22.558
The flow control, related frames and maintain state per stream, uh, for, uh, uh, for those frames basically.

96
00:10:22.558 --> 00:10:25.558
Uh, then there is an entity called a frame.

97
00:10:25.558 --> 00:10:30.149
Uh, which, uh, the information about, hey.

98
00:10:30.149 --> 00:10:43.349
I got a frame, I read a frame, it has the stream ID where is the, the channel for the stream ID and when it looks up into the map and it basically fires the event on that, uh, on that channel.

99
00:10:45.984 --> 00:10:59.692
Which is the, which 1st goes through the unsafe, which, which implements the Navy flow control uh, which, um, which you all know is about, like, read and read complete methods.

100
00:10:59.969 --> 00:11:10.349
So, based on that, whether there is a pending read or not, uh, either, it will buffer, uh, the message inside the unsafe or.

101
00:11:12.389 --> 00:11:12.958
Uh,

102
00:11:13.073 --> 00:11:14.573
when it does pass it through,

103
00:11:14.573 --> 00:11:17.573
this is a new concept that we have added,

104
00:11:17.604 --> 00:11:18.083
uh,

105
00:11:18.203 --> 00:11:20.094
which are called validators,

106
00:11:20.124 --> 00:11:20.543
um,

107
00:11:21.234 --> 00:11:23.484
which are taken from uh,

108
00:11:23.514 --> 00:11:24.384
but the,

109
00:11:24.413 --> 00:11:30.234
the positive of using these validators are essentially that we can all the validation,

110
00:11:30.234 --> 00:11:30.653
which is like,

111
00:11:30.653 --> 00:11:31.134
frame,

112
00:11:31.163 --> 00:11:31.644
um,

113
00:11:32.124 --> 00:11:33.144
related in the scans,

114
00:11:33.173 --> 00:11:33.384
like,

115
00:11:33.384 --> 00:11:38.724
which frames are allowed with sequence of frame is allowed is encapsulated inside a single handler,

116
00:11:38.874 --> 00:11:40.014
which makes it easier to,

117
00:11:40.014 --> 00:11:41.033
like you said about.

118
00:11:42.658 --> 00:11:48.778
Once it passes through the validators it goes into the user handlers that are specified for that.

119
00:11:50.129 --> 00:11:57.808
Questions, so what what does the encoder do.

120
00:11:57.808 --> 00:12:00.928
On the child stream, but.

121
00:12:00.928 --> 00:12:07.408
Good question that was in the in the right side. So next I'll go to the right side. So that's good.

122
00:12:09.058 --> 00:12:14.519
Any other question.

123
00:12:14.519 --> 00:12:19.139
Or upgrades handles, uh.

124
00:12:19.139 --> 00:12:26.249
Like, uh, like, lpn based, or, um, uh, 1 to like, the.

125
00:12:26.249 --> 00:12:31.798
Okay, uh, either or upgrades.

126
00:12:31.798 --> 00:12:43.198
So, and that's another bit that we have that, uh, that is in the, in the next few slides. There is, there is a new entity called, like the.

127
00:12:43.198 --> 00:12:47.999
To SSL context, which encapsulates the lpn, uh, configurations.

128
00:12:47.999 --> 00:12:52.229
Um, but it happens on the channel on the same today.

129
00:12:54.899 --> 00:13:01.798
But, basically, this is something like, uh, what you have now for quickest context, where you have the.

130
00:13:01.798 --> 00:13:07.379
Application, uh, protocol. That's correct. Yes. That is what it is.

131
00:13:07.379 --> 00:13:11.818
Okay, um, he asked what about.

132
00:13:11.818 --> 00:13:20.519
Yes, that's correct. Yeah. Yeah. So I, uh, so, uh, that was 1 of the discussions, uh, that, um.

133
00:13:20.519 --> 00:13:25.649
That we were having internally as to, whether it should be support upgrades or not.

134
00:13:25.649 --> 00:13:32.489
Uh, but if it were to be, uh, it would, it can happen on the parent channel essentially.

135
00:13:32.489 --> 00:13:35.729
That's what I understand. It doesn't the PFC doesn't have it today.

136
00:13:37.708 --> 00:13:41.788
Is it.

137
00:13:41.788 --> 00:13:50.458
Just 3rd um, yeah, because, uh, for the text also, it may be interesting to note that tax upgrades are basically duplicated.

138
00:13:50.458 --> 00:13:56.038
Yeah, so there's an open issue in the, um.

139
00:13:56.038 --> 00:14:02.399
Um, for the next, uh, revision of it, and they basically remove, um, the clear text upgrade.

140
00:14:02.399 --> 00:14:07.678
So, that was step. Yeah, that's essentially the reason why you were thinking, should be supported or not.

141
00:14:10.769 --> 00:14:14.038
Julian, you had you had a question? Yep. Uh.

142
00:14:14.038 --> 00:14:17.278
On the message on the channels.

143
00:14:17.278 --> 00:14:25.259
Is it is it plan to reuse the existing HTP messages? Or is it, uh, new messages that will be used.

144
00:14:26.394 --> 00:14:35.244
Yeah, good question I think the 2 things here 1 is like, the mess like object hierarchy and frames.

145
00:14:35.754 --> 00:14:47.783
So this basically has, like, we have changed the to frame definition in the, because it is using buffer, which is a new API and it is a little bit different from what exists today.

146
00:14:48.293 --> 00:14:55.014
But, like, what we do today, we would have a adapter for and vice versa.

147
00:14:55.349 --> 00:15:05.188
So there will be and those adapters will be mandatory or can we work with the native, uh, frames if you want instead of using.

148
00:15:05.188 --> 00:15:15.658
Yes, send it to this. Oh, totally. Yeah, you can you can directly work with the frames and that's essentially the expected. Wait. Okay so if you use the setup, it will look.

149
00:15:15.658 --> 00:15:20.548
A lot like the HDP 2 chilled API, right?

150
00:15:22.229 --> 00:15:31.739
Uh, actually, like, without the adapters frames are what flows in on the child panel pipeline. Oh, okay. I see. I see. I see. And we can use that if you want.

151
00:15:31.739 --> 00:15:36.448
Exactly, if you want it to look just like 1, then you can use the doctors.

152
00:15:36.448 --> 00:15:40.678
Okay, because 11 concern, I think is also a.

153
00:15:40.678 --> 00:15:45.778
I don't know much about it, but it's the but.

154
00:15:45.778 --> 00:15:52.288
Yeah, and it would be good to I think as far as I understand it.

155
00:15:52.288 --> 00:15:59.849
That we need to use that if you want to use the count web sockets to check.

156
00:16:01.619 --> 00:16:07.739
That is an interesting question. Now when do you do you know, how does web socket work today on and does it.

157
00:16:07.739 --> 00:16:11.099
I actually have no idea. I never looked into.

158
00:16:11.099 --> 00:16:15.058
Uh.

159
00:16:17.068 --> 00:16:26.788
So, what were you saying is different about the objects that are flowing other than the buffer type being different.

160
00:16:28.408 --> 00:16:34.589
Uh, so so this has, um, doesn't reuse what is there today.

161
00:16:34.589 --> 00:16:38.519
In in, uh.

162
00:16:38.519 --> 00:16:42.509
It has its own hierarchy, but.

163
00:16:42.509 --> 00:16:47.849
But, I mean, it is similar to what it was. Uh, the biggest change is the buffer, uh, thing.

164
00:16:47.849 --> 00:16:56.489
Okay, but we would expect, I mean, it basically to be done in place, I mean, we're going to rename everything anyway because of the package.

165
00:16:56.489 --> 00:17:04.019
Changes, but is it essentially looking at being in place? Or is there something more fundamental about how it's done.

166
00:17:04.019 --> 00:17:08.398
Because the buffer change is going to be done all over Nadia as well.

167
00:17:08.398 --> 00:17:20.608
Yes, yes, totally. Yeah. I mean, apart from that, there is nothing fundamental that exchanging. I mean, there is there's a basic thing around, like, there is a basic like, control frame interface, which empty control, printing scans, but.

168
00:17:20.608 --> 00:17:28.858
Nothing drastic yeah. Okay. Okay. Okay. It, it's, it's just, uh, to to allow us to do the before. We're ripping up everything.

169
00:17:28.858 --> 00:17:32.939
That's right. Okay. Yes yes.

170
00:17:32.939 --> 00:17:41.128
I know it's not related, but, um, are there plans to update or improve the APIs?

171
00:17:42.598 --> 00:17:52.648
Um, I think in specific, nothing big per se, like, you have something in mind to them like, I have, we don't have.

172
00:17:58.078 --> 00:18:01.348
Had a quick question. Um, so does the.

173
00:18:01.348 --> 00:18:05.669
Connection level readability change, um.

174
00:18:05.669 --> 00:18:09.088
Connection becomes remove the whole.

175
00:18:09.088 --> 00:18:17.548
Like, it was, it was hard to hear you, uh.

176
00:18:17.548 --> 00:18:23.519
The, if the connection readability changes to set up in office streams, uh, or does it just get to that?

177
00:18:23.519 --> 00:18:33.808
1 control stream. Oh, so the readability would be like, would be on the channel channel right? Ability not readability.

178
00:18:33.808 --> 00:18:40.739
Oh, yeah, the readability also, but like, all those callbacks will be same on a channel channel. Uh.

179
00:18:40.739 --> 00:18:44.098
When there are like, the control window updates, basically.

180
00:18:48.898 --> 00:18:56.608
Does that answer your question? So, each child channel would get updated within the connection level.

181
00:18:56.608 --> 00:19:01.798
Credibility changes not the connection level. It will be for that stream.

182
00:19:06.659 --> 00:19:10.769
What Carl's asking is, like, if we get a connection level, uh, window update.

183
00:19:10.769 --> 00:19:17.219
Would that potentially propagate down to each channel child channel and calls the right ability change?

184
00:19:17.219 --> 00:19:30.148
Yeah, that's cool. Yeah. Okay. I don't think that is the case right now, but it may be I mean, it is a good question to see, I'll I may have to check back, but it'll, it'll be on the control stream for sure.

185
00:19:30.148 --> 00:19:34.949
I'll take some notes here too. Yeah. Good question. Yeah.

186
00:19:34.949 --> 00:19:39.209
Okay, I think it probably should go to the streams, but.

187
00:19:40.013 --> 00:19:45.084
We are incorporating flow control. I think we kind of have to do that. Yes, I'll take it away. Anyways.

188
00:19:45.503 --> 00:19:57.294
You can keep the connection flow control, separate from the stream flow control, which has deficiencies as far as maybe memory usage, but has advantages as far as, um.

189
00:19:57.598 --> 00:20:04.019
Waking up the world every single time you get a single window update so there's, there's going to be just trade offs there.

190
00:20:04.644 --> 00:20:19.433
Right, right okay. And also in ever you wake up the child channels, there's some allegation allocation problems. Uh, basically, you're going to wake up 1 of them that when can then right? Which will then take it away.

191
00:20:19.884 --> 00:20:23.273
Um, before the other ones have have even.

192
00:20:23.548 --> 00:20:34.979
And it had a chance to consume it. I think earlier we were, I was purposely not doing that because otherwise you have severe fairness issues and things like that to work through.

193
00:20:34.979 --> 00:20:38.278
I was just keeping the strings independent.

194
00:20:38.278 --> 00:20:45.118
But there's I, I wouldn't be surprised if other people wanted to do it otherwise.

195
00:20:46.288 --> 00:20:54.778
Okay, okay. Circle back Eric. I remember discussing this as well. So I have some some context there, but yeah, I'll take a note. We can circle back to this.

196
00:20:54.778 --> 00:21:04.558
Cool. Cool. All right quick question about web socket. If I understand you correctly. Only upgrade possible.

197
00:21:04.558 --> 00:21:08.548
Yeah, once with a connection upgrade kind of a.

198
00:21:08.548 --> 00:21:13.138
Which is required for web sockets is it not supported in.

199
00:21:13.138 --> 00:21:23.489
Yeah, so I so web sockets, I think if I understand it, right? The web socket upgrades would be on a stream.

200
00:21:23.489 --> 00:21:29.219
If you are doing connect extended frame and.

201
00:21:29.219 --> 00:21:35.548
That's why we need them to be able to use the web socket to do the handshake when we get to trim.

202
00:21:35.548 --> 00:21:40.888
Thought at the end loss should be under this Fred specific frame.

203
00:21:40.888 --> 00:21:44.308
And perform the end check and signal it to the application.

204
00:21:46.648 --> 00:21:51.269
Yeah, yeah, so like, web socket, I, I have to see more and.

205
00:21:51.269 --> 00:21:55.979
And I'm going to be doing, we don't know whether it works today also, but.

206
00:21:55.979 --> 00:22:04.378
I will that's that's a good point. We can kind of like, look through once we have things in place, because he doesn't have like, anything related to WebSocket right now.

207
00:22:04.378 --> 00:22:07.469
Thank you. Okay.

208
00:22:07.469 --> 00:22:12.749
Great. Okay. Moving on. There's like 20 minutes left.

209
00:22:12.749 --> 00:22:18.929
Okay, just yes. Ask a question. Yes. Uh, how about flushing.

210
00:22:20.459 --> 00:22:30.028
That's actually refreshing. Yes. Or, uh, is there a global flush or fresh strategy that aggregate? So he's able to be batch to batch stuff.

211
00:22:30.864 --> 00:22:39.894
Yeah, great. Let's go through the right and just include limited failure. Yeah. Okay. Um, so let's go to the control flow of, uh, rights.

212
00:22:39.923 --> 00:22:46.884
Um, as you would expect, uh, there's a child channel you can write on the child channel using, like.

213
00:22:47.189 --> 00:22:50.699
Chandler trade as usual uh.

214
00:22:50.699 --> 00:22:54.929
You would expect to go through the user handler 1st um.

215
00:22:54.929 --> 00:23:04.169
Validates there are a few validation on the night. We are kind of lax on validations venue. Right? Because like, you can write the way you want.

216
00:23:04.169 --> 00:23:15.419
Then the next step comes in where, in the flow control handler intercepts the message or the frame that you're writing there is there is a queue inside this low control. Handler.

217
00:23:15.419 --> 00:23:18.868
Which, basically looks at the.

218
00:23:18.868 --> 00:23:31.558
Writable bites allowed for that channel. Uh, if it is not writable, it will queue. And then when the bites, uh, when more trades are available, basically, um.

219
00:23:31.558 --> 00:23:34.949
Uh, pass through the right. Uh, essentially, but in the pipeline.

220
00:23:34.949 --> 00:23:39.209
Um, did, uh, and this is.

221
00:23:39.209 --> 00:23:46.199
So, uh, there is this another, um.

222
00:23:46.199 --> 00:23:54.989
Yeah, so the, the flow control handler basically, uh, and I, I covered a little bit in the for the slides but, uh, since there is this, um.

223
00:23:55.824 --> 00:24:09.713
Like, interaction between parent and the child channels for flow control. There are packaged private APIs, um, that, uh, enables that interaction between parent and child. I'll go through it a bit.

224
00:24:09.743 --> 00:24:12.023
Uh, in the in the slides coming up.

225
00:24:12.298 --> 00:24:25.409
Uh, and then after the flow control, handle, it passes through the frames, it gets included into bytes, goes through the unsafe and which essentially, right on the parent channel.

226
00:24:25.409 --> 00:24:30.118
The thing that you would see differently here is, uh.

227
00:24:30.118 --> 00:24:39.358
There are no flashes strategies, uh, children as you will kind of pointing out. Uh, we always write on the parent channel and then.

228
00:24:39.358 --> 00:24:43.318
Because they're like different from today. Uh.

229
00:24:43.318 --> 00:24:46.769
Any plus strategy that you put on the parent.

230
00:24:46.973 --> 00:24:47.814
Could be used,

231
00:24:47.844 --> 00:24:48.084
uh,

232
00:24:48.084 --> 00:24:49.433
so by default,

233
00:24:49.433 --> 00:24:52.523
we could do the same thing as we're doing today around like,

234
00:24:53.034 --> 00:24:54.173
unless we have finished reading,

235
00:24:54.173 --> 00:24:55.824
we don't flush and at the end of the meeting,

236
00:24:55.824 --> 00:24:58.763
we flash or you can add any more strategies,

237
00:24:59.153 --> 00:25:00.804
which is different than today because it is right now,

238
00:25:00.804 --> 00:25:01.044
like,

239
00:25:01.044 --> 00:25:02.334
kind of inside the and say,

240
00:25:02.483 --> 00:25:02.814
um.

241
00:25:03.118 --> 00:25:13.048
Implementation, but that's that's a flush on the child channel, produces a flush on the parent channel. It's not that are right on the the.

242
00:25:13.048 --> 00:25:16.709
Child channel produces a flush on the parent.

243
00:25:17.909 --> 00:25:29.068
So like this, this right this right and flush, uh, for the near the unsafe that's only generated by a flush on the child channel.

244
00:25:29.068 --> 00:25:32.759
A normal buffering, um.

245
00:25:32.759 --> 00:25:37.618
It right before that unsafe. Correct correct that's correct.

246
00:25:37.618 --> 00:25:42.568
Yes, but once it gets to the parent, you can you can add your plus strategies.

247
00:25:42.568 --> 00:25:50.278
Just mentioning Julian did that answer your question about.

248
00:25:57.358 --> 00:26:00.719
I see what what.

249
00:26:00.719 --> 00:26:12.058
Is trying to be achieved or why is the, like, most of this I can sort of see where you're trying to go and what benefits you're trying to do and so this, the flow control handler on the child channel on the frames and coder.

250
00:26:12.058 --> 00:26:15.358
On the child channel, what's.

251
00:26:15.358 --> 00:26:22.858
Why are this on the child channel? What? What advantages is that getting us or what it promises? It's all.

252
00:26:24.689 --> 00:26:28.679
In in my mind, I always more.

253
00:26:28.679 --> 00:26:33.538
Children did you do you say some time.

254
00:26:35.189 --> 00:26:39.719
No, sorry, I was just sending a colon seeing. I have to call back later so.

255
00:26:39.719 --> 00:26:51.689
Okay oh, no worries. Um, uh, so, Eric, like, uh, what my intention here was to basically, like, make it.

256
00:26:51.864 --> 00:27:03.233
More clear from the pipeline as to what is happening on the channel, which gives us better visibility, uh, around, like, each channel events. That is the motivation for putting it on the channel channel.

257
00:27:03.713 --> 00:27:07.584
But you could, I mean, we can just use the normal flow control handler in.

258
00:27:07.858 --> 00:27:12.598
Is is this allows us.

259
00:27:12.598 --> 00:27:19.828
Does this allow us to just change the full control handler per stream if we wanted to have a different strategy per stream or what.

260
00:27:19.828 --> 00:27:29.878
Because, like, it actually makes it more uptake in my mind because you're not, you're just gonna see bytes now between the child channel and the parent channel.

261
00:27:29.878 --> 00:27:41.429
The frames and coder can't even encode headers because that's kinda deal with. So the only thing you're encoding there and window updates aren't going through it. So, the only thing you're encoding there is HP data frames.

262
00:27:41.429 --> 00:27:44.759
Which sounds sort of like, what's the point.

263
00:27:44.759 --> 00:27:50.219
So, hey, this campaign coded, uh.

264
00:27:50.219 --> 00:27:57.538
Because, I mean, you need the window unless unless you're sharing the H pack encoder across the different.

265
00:27:57.538 --> 00:28:06.058
That yeah, that would be the intent here, but then you, that's very scary because the flush behavior, like, those can get reordered. Very trivially.

266
00:28:06.058 --> 00:28:12.838
Um, that's that's beyond scary to me. Like, it can maybe be made to work, but.

267
00:28:14.189 --> 00:28:22.709
Um, if we were, if we, like, we're running these on different threads or something like that, I could also understand, you know, us trying to split things off. But, um.

268
00:28:22.709 --> 00:28:27.449
These are all pretty much together. Uh, I would say.

269
00:28:28.709 --> 00:28:33.598
Are so the flow control handler that does not use window updates between the.

270
00:28:33.598 --> 00:28:38.009
The parent channel on the child channel, that's just a direct.

271
00:28:38.009 --> 00:28:42.568
Method calls is that right? So we're avoiding the overhead of the.

272
00:28:42.568 --> 00:28:49.199
New updates, uh, are we good? Uh, today it is writing the window update in the.

273
00:28:50.153 --> 00:28:54.834
But, I mean, we could do that. I'm assuming you. Okay. That's fine.

274
00:28:54.834 --> 00:29:05.542
I was I'm just trying to seek out what, what advantages we're we're we're getting because I like writing the Windows updates sounds a lot nicer if we can.

275
00:29:05.818 --> 00:29:10.528
You know, those sorts of things are great if we can get away with it.

276
00:29:10.528 --> 00:29:19.828
Okay, I guess I just question we can move on, but I question having the, the, the encoder.

277
00:29:19.828 --> 00:29:24.028
And maybe even the flow control handler, um.

278
00:29:26.128 --> 00:29:31.019
Okay, okay yeah, if the flow control handler is just handling the buffering.

279
00:29:31.019 --> 00:29:36.298
Um, yes, that is what it is doing today. So, uh.

280
00:29:36.298 --> 00:29:50.578
Okay, yeah, yeah. Good point. I think let's noted down from from the APAC point of view. I mean, what made it more be more comfortable doing that was that we are doing the same thing for it's like you back. So, uh.

281
00:29:50.578 --> 00:29:55.618
But, but like, when when we get to it, maybe maybe it's quicker.

282
00:29:55.618 --> 00:30:06.659
You can do it. Yep. Yeah I think that's a good comment. I took a note here, Eric, and we can circle back to that. I know we had similar discussions internally so I think that's probably worth revisiting.

283
00:30:06.659 --> 00:30:10.499
Totally, totally. Is that.

284
00:30:10.499 --> 00:30:13.618
Okay, um.

285
00:30:14.729 --> 00:30:19.499
Cool yeah, I have a couple of questions. Okay. Sorry yeah. Yeah. Yeah.

286
00:30:19.499 --> 00:30:22.858
The 1st question is, is the frame on quarter.

287
00:30:22.858 --> 00:30:28.259
I'm calling for the frame, or is it on calling the content and then the, the.

288
00:30:28.259 --> 00:30:35.969
The pound channel will take care of on coding the, the prefix and, uh, the adding of everything.

289
00:30:35.969 --> 00:30:41.098
Now, everything is included by the payment code today. It will be yes.

290
00:30:41.098 --> 00:30:47.128
Otherwise there will be a copy. Oh, yeah. Yeah. So is your question is, um.

291
00:30:47.128 --> 00:30:53.459
How does the application interacts with different control? Uh, ideally, it doesn't.

292
00:30:53.459 --> 00:30:59.999
Okay, because the interface here is only frames. So, like, if you want to do something, you basically write the frame.

293
00:31:00.653 --> 00:31:14.993
Yeah, but how can I be aware of that? There's a, I shouldn't that's showing happening. I should not be true and you shouldn't be writing frames and when I, when I can when the 2 internal tree is drained, how can I resume activities.

294
00:31:15.778 --> 00:31:20.308
Got it got it that's like the, the, the, uh, uh.

295
00:31:20.308 --> 00:31:23.878
Apis of basically that's what it is translated to.

296
00:31:23.878 --> 00:31:27.298
Okay, you would get the channel, right? And let you change the event yes.

297
00:31:28.439 --> 00:31:33.239
Thank you. Cool. Awesome.

298
00:31:33.239 --> 00:31:42.989
Uh, so we went over a little bit about the APIs, the structure per se. Uh, but like, this is this is kind of listing notable APA changes.

299
00:31:42.989 --> 00:31:50.368
1st thing, uh, which seems which is different, is that you can actually explicitly create a stream, uh, using channel.

300
00:31:51.659 --> 00:32:03.233
Uh, which gives us screen channel, uh, um, interface back extensive channels, just regular channel, uh, and, uh, the stream States.

301
00:32:03.263 --> 00:32:13.733
Uh, this is how they are mapped, uh, onto, like, the native channel events not everything is mapped, but we have done like, what, what makes the best sense over here.

302
00:32:14.038 --> 00:32:17.638
Um.

303
00:32:17.638 --> 00:32:23.068
Pass through this, because this is something where we can probably, uh, discuss offline to, uh.

304
00:32:23.068 --> 00:32:28.828
As I was mentioning before there are a few validators which we have, like, uh.

305
00:32:28.828 --> 00:32:38.429
Got inspiration from they basically, like, put together, uh, all related validations uh, these are the 3 validations that exist today.

306
00:32:40.433 --> 00:32:44.723
Uh, this was the SSL context, uh, related to the previous question.

307
00:32:44.784 --> 00:32:57.084
Uh, and this again, like, up for discussion, uh, this seems a little heavy handed for this kind of just 1 feature, which is like, 1, uh, like lpn handling but this is how it exists today.

308
00:32:57.084 --> 00:33:06.864
Like, on the Excel context, Bill builder, you can say I want to support also and this is my initiatives a pipeline, which makes it a little easier to do 1 and 2 both.

309
00:33:09.179 --> 00:33:17.939
This is kind of what we were talking about and flow control 1 distinct change here is.

310
00:33:17.939 --> 00:33:24.689
That we are trying to reduce the APIs, which are which we are allowing folks to.

311
00:33:24.689 --> 00:33:29.578
To have like a totally custom look control, uh, algorithm, uh.

312
00:33:29.578 --> 00:33:38.368
What it would mean is that you would have to, like, remove the flow control, handles that exist and use your own doing the things that you want to.

313
00:33:38.368 --> 00:33:46.828
So this is this may be a bigger change if you were doing a full control, uh, custom token, rely algorithms today.

314
00:33:46.828 --> 00:33:53.548
Um, if we do, uh, see more people interested, we can probably, like, bring back thing. But that's that's kind of what.

315
00:33:53.548 --> 00:34:02.909
Yes, uh, at at the moment we standard alarms is this is this something? Okay. Okay.

316
00:34:09.983 --> 00:34:23.094
In case, you're not aware I think the assumption from our side is we, we currently have 2 algorithms, um, 1, which, like, cares about priority and builds the priority tree, et cetera that's used by default. So, like, if you don't change anything, that's what you're getting.

317
00:34:23.369 --> 00:34:30.628
The performance was improved a while ago, so it, it works. Well, in the default case, we also have a.

318
00:34:30.628 --> 00:34:34.528
You can opt out where you don't pay the cost to building the priority tree.

319
00:34:34.528 --> 00:34:43.079
Um, and kind of do piecemeal allocations and we, uh, for the use cases, we've seen either 1 of those seem to be sufficient.

320
00:34:43.079 --> 00:34:46.079
But, yeah, it's in touch that if anyone.

321
00:34:46.079 --> 00:34:49.469
Has more custom use cases now would be the time.

322
00:34:49.469 --> 00:34:55.438
To let us know as we're planning on, kind of just supporting those 2.

323
00:34:55.438 --> 00:35:04.259
Uh, algorithms that you can specify from the outside, rather than exposing APIs to directly control this, which are a bit more involved and cross different layers.

324
00:35:07.559 --> 00:35:16.139
Although if someone didn't want any help making flow control API with this new set up.

325
00:35:16.139 --> 00:35:20.909
It's just a handler, right? Yep. Yep. It's a handler.

326
00:35:20.909 --> 00:35:25.349
But barring the, the, the packaged private interaction between.

327
00:35:25.349 --> 00:35:31.079
Oh, okay. Okay. Okay. That's that's great. Okay. Okay. Yes. Yes.

328
00:35:31.079 --> 00:35:35.818
Okay, okay cool.

329
00:35:37.289 --> 00:35:50.878
Moving on, like, this is going over the same things. So this may say, um, this may make this smarter, uh, like, basically, like, the interaction is through a custom interface just called, like, um.

330
00:35:50.878 --> 00:35:58.798
Distributed or something, uh, and you can, you can basically register reading right side, uh, create the distributions.

331
00:35:58.798 --> 00:36:07.289
And then there are these 2, uh, like, there are a few callbacks on the parent handler, which tells, like, when invite is written by different.

332
00:36:07.289 --> 00:36:12.958
Essentially, um, otherwise you get the credits, uh, from the, from the parent channel.

333
00:36:12.958 --> 00:36:17.398
So, if if whenever.

334
00:36:18.539 --> 00:36:24.628
Okay, so I guess it will trigger. This will be a little bit chatting between the 2, right?

335
00:36:24.628 --> 00:36:31.018
Right, yes, yes, yes they will be the credit distribution coming from parent to child.

336
00:36:31.018 --> 00:36:34.949
And child to pen, it would be callbacks when it is consumed.

337
00:36:34.949 --> 00:36:41.699
And whenever there's window updates, whenever the child is told of window updates that can cause rights.

338
00:36:41.699 --> 00:36:47.398
Um, directly. Okay. Okay. Thank you. Thank you.

339
00:36:47.398 --> 00:36:51.628
All right.

340
00:36:51.628 --> 00:37:02.969
Any more questions and control cool. Uh, we have about 5 minutes. Yes, yes yes.

341
00:37:02.969 --> 00:37:13.974
Yeah, this is kind of like the last bit, I think. Yeah. Um, so, uh, as I was mentioning is something that exists today, it's just an experiment, uh, get feedback.

342
00:37:13.974 --> 00:37:22.853
Otherwise, I mean, it's more likely we'll remove it, but we see how it goes. So, I'll not spend a lot of time on it. I'll, I'll go on the examples real quick.

343
00:37:24.389 --> 00:37:27.838
This is how this is a good example. Look like, um.

344
00:37:28.284 --> 00:37:40.014
So, you basically create this little context and then when you're building the codec, you give this thing called any visualizer, uh, which is provided by the by the binary itself.

345
00:37:40.554 --> 00:37:54.744
Uh, the thing that it gives you control over that you can initialize the control stream as well as this request stream. So, every time there is a new request being accepted on a channel, uh, you would get a call back here and you can initialize that stream.

346
00:37:55.048 --> 00:38:01.228
And this, the service stream initialize it is, uh, it's basically for each connection.

347
00:38:02.338 --> 00:38:14.610
Um, and then, well, and then there is like an inbound handler that you can use to, like, just, uh, if you, it's a simple app, they can get just, like, get callbacks data.

348
00:38:14.610 --> 00:38:22.949
And the best you can use your own. This is a bit simple, but but the code wise, it looks very much like, it should be 3 essentially.

349
00:38:24.599 --> 00:38:31.440
Um, I'll go with the client, and then we can ask, uh, like, we can have some time to spend on on the questions in Central.

350
00:38:31.440 --> 00:38:36.449
The client side is a little bit more involved. The.

351
00:38:36.449 --> 00:38:47.550
The initializes are for each connection, so whenever you have to connect, you have to create this initialize it, uh, similar to the server. You would have a way to initialize the control stream.

352
00:38:48.659 --> 00:38:56.789
And, uh, Ben, for that particular channel, when you initializing the channel, you're creating the builder, you would pass that initialize that.

353
00:38:56.789 --> 00:39:03.210
Uh, now, since we basically, like, there should be to channel implementations.

354
00:39:03.210 --> 00:39:11.905
Wrap the existing channel. So what this and this is something that, like, open for feedback this is what I figured would be the easiest way to do.

355
00:39:12.355 --> 00:39:23.425
Uh, you would, you can convert the Connect future to channel, connect future, using this method, uh, which gives you the, um, uh, the actually be the channel.

356
00:39:23.730 --> 00:39:33.300
and then you can use it should be channel to create streams as much as you want uh same stuff you on the stream you would have um 

357
00:39:33.300 --> 00:39:48.300
You would have the, the request stream inbound handle. I didn't have anything like, highlighting that, but for that stream, you can create your request stream in bone handling just like, on the server to handle per request. Uh, and then you can write to the stream.

358
00:39:48.300 --> 00:39:52.920
Uh, and then essentially, like, read the response, uh, using that handler.

359
00:39:54.480 --> 00:39:58.829
So, that's how the examples look like.

360
00:39:58.829 --> 00:40:08.460
Again, apologies, we are running out of time, but but like, we can, we can spend a few minutes to ask, uh, like questions or thoughts around examples. Per se this is the last slide.

361
00:40:12.869 --> 00:40:21.300
Uh, small question on the implementation is it the channels still using the channel framework?

362
00:40:21.300 --> 00:40:25.050
No, no, no embedded channels there. Okay.

363
00:40:25.050 --> 00:40:28.559
Thank you quick question.

364
00:40:28.559 --> 00:40:35.099
But, yeah, I was just saying, I don't think we used to enter the channel.

365
00:40:35.099 --> 00:40:40.380
Today as well, yeah, yeah. We only we only use them for compression at the moment.

366
00:40:40.380 --> 00:40:50.789
But that's it, which, which also not been removed. Yes, we have the channels and streaming closer to the local channel.

367
00:40:50.789 --> 00:40:54.179
That because that's what it was copy from.

368
00:40:54.179 --> 00:41:01.260
true true it is yeah and also copies from the existing yes it is to 

369
00:41:01.260 --> 00:41:11.280
Inhibiting that, so so a lot of these things were things that we gave up before, um, what things do we think how do we think we can get that.

370
00:41:11.280 --> 00:41:15.780
Performance, so there were we have less synchronization in the pipeline now.

371
00:41:15.780 --> 00:41:22.019
Then back back, then we can maybe optimize the child channel.

372
00:41:22.019 --> 00:41:34.974
Uh, itself creation and something like that but, like, 1 of the things we gave up in order for performance was just separating the frame codec from the multiplex codec because those 2 were originally separate.

373
00:41:35.275 --> 00:41:39.235
And now the, the multiplex extends the frame. Codec.

374
00:41:39.480 --> 00:41:51.119
So that Eric, that's not true anymore. I mean, we still have it, but it's duplicated. So, these days, actually, um, you can use both as a separate handler.

375
00:41:51.119 --> 00:42:00.989
And, um, you can yeah, the last time we did the benchmark, it didn't make a lot of difference actually. Okay, great. Great. So, those are already split up.

376
00:42:00.989 --> 00:42:07.199
Yeah, um, yeah, and I had hopes that I'd be able to split up the, the, um.

377
00:42:07.199 --> 00:42:11.219
That we'd be able to split up the flow control handler into its own.

378
00:42:11.219 --> 00:42:19.320
So, I, I guess at some point, we'll just talk more about the, the child channel.

379
00:42:19.320 --> 00:42:27.150
Yeah, it's, it's also about like, the overhead that you actually have when the pipeline becomes.

380
00:42:27.150 --> 00:42:32.190
Longer right. I mean, it's not only the problem the channel, it's also a problem in itself.

381
00:42:32.190 --> 00:42:40.050
We kind of, um, removed some of the overhead here by, um, adding like the skip annotation kind of thing, right?

382
00:42:40.050 --> 00:42:48.780
And, um, all of these, these annotations are actually present on the default implementation. So as long as you don't overwrite them, you don't pay any price for them.

383
00:42:48.780 --> 00:42:54.119
I think that's 1 of the, the things that that helped when we, um.

384
00:42:54.119 --> 00:42:57.599
That allowed us to split these handlers as well.

385
00:42:57.599 --> 00:43:05.130
So, Carl, I know you raise your hand, let's finish this and then we can so.

386
00:43:05.130 --> 00:43:09.210
There's 1, overarching concern for me, uh, which is like.

387
00:43:09.210 --> 00:43:14.909
There's a new nitty version coming out and there's a new API coming out. Um, which means that, like.

388
00:43:14.909 --> 00:43:19.559
If there are problems that we didn't proceed, like, it'll be very hard to back out. So I'm wondering, like.

389
00:43:19.559 --> 00:43:23.909
What is the release ordering for this? And have you seen substantial.

390
00:43:23.909 --> 00:43:27.119
Uh, application code, using this new API to, like, you know.

391
00:43:27.119 --> 00:43:30.780
Take it for a spin, um.

392
00:43:30.780 --> 00:43:37.260
Quick question, Carolyn, and I think that's that's kind of like what is coming with 95. there's a ton of changes like.

393
00:43:37.260 --> 00:43:40.739
Starting from buffer to other APIs like, it is.

394
00:43:40.739 --> 00:43:50.429
Very different than, uh, then for so, I think, like, totally, like, there would be challenges, like, adopting it and particularly production. Our intent.

395
00:43:50.429 --> 00:43:53.519
Now, as as we would, uh, initially mentioning.

396
00:43:53.519 --> 00:43:57.840
Is to, like, do an alpha release and in February.

397
00:43:57.840 --> 00:44:09.030
Uh, and then, like, kind of like, work with different frameworks and different, like, contributors to, to, to roll this out. I would see, like, different alpha version so different frameworks coming up.

398
00:44:09.030 --> 00:44:09.864
Using this thing,

399
00:44:11.905 --> 00:44:12.264
uh,

400
00:44:12.594 --> 00:44:12.804
yeah,

401
00:44:12.835 --> 00:44:14.485
concerning the release,

402
00:44:14.514 --> 00:44:17.574
you mentioned the alpha in February 2022 uh,

403
00:44:18.474 --> 00:44:19.195
do you have,

404
00:44:19.675 --> 00:44:20.244
um,

405
00:44:20.275 --> 00:44:20.815
estimates for the,

406
00:44:20.815 --> 00:44:22.525
for the,

407
00:44:22.525 --> 00:44:23.905
I mean,

408
00:44:23.965 --> 00:44:26.514
for the data and final and what what.

409
00:44:28.230 --> 00:44:33.510
I know I'm not asking for dates. I'm asking what's in your mind and what's your vision?

410
00:44:33.510 --> 00:44:37.349
Yes, yeah, yeah.

411
00:44:37.349 --> 00:44:51.780
I think, like, uh, our thought right now, uh, Norman and Scott, like, jump in. But our thought right now is to I, I think once we have the release, it'll people get more serious will be able to actually integrate and use it.

412
00:44:51.780 --> 00:45:03.360
To get more feedback. So based on that feedback from our side, I think we will, we will see that. The APIs are kind of where we want them to be. Uh, and then based on the feedback, we iterate a little. So I am.

413
00:45:03.360 --> 00:45:12.719
I am like, at least internally what we have thought about is through, like, September timeframe, we should be able to get to a release candidate sort of.

414
00:45:12.719 --> 00:45:15.869
Uh, is what is another line at this point?

415
00:45:15.869 --> 00:45:19.800
Yep sounds good. Yeah. Yeah.

416
00:45:20.875 --> 00:45:33.295
I think I think that's right. I think that's what we're certainly shooting for, but I think Karl kind of hit the nail on the head that it's also subject to getting some real usage and, like, right now this is a prototype API.

417
00:45:33.295 --> 00:45:39.565
So, we certainly have internal discussions, but, like, I think, you know, we will learn more when the rubber meets the road.

418
00:45:40.050 --> 00:45:48.809
And we start getting, like, releases that can be used in, like, a more real capacity. So, timelines might shift based upon, you know, that feedback and.

419
00:45:48.809 --> 00:45:52.199
Experience we get us as we, as we go through that process.

420
00:45:52.199 --> 00:45:58.260
It looks though that most of this is going to be the same from the user's perspective.

421
00:45:58.260 --> 00:46:04.920
Like, you're going to have a construction pattern to be slightly different, but other than that.

422
00:46:04.920 --> 00:46:13.409
It doesn't seem that invasive. I mean, implementation wise, there's, there's a lot going on, but it it doesn't seem.

423
00:46:13.409 --> 00:46:19.619
It seems like no, 1 for some applications might no, 1 might notice this change.

424
00:46:20.275 --> 00:46:30.534
Yeah, I think depending on where you are in the stack for sure this could be transparent. I mean, obviously there's API changes, but yeah, the semantics, the goal, like, the semantics of aren't changing.

425
00:46:30.534 --> 00:46:38.394
So, like, we for sure want to clean up the APIs, consolidate, improve performance, that type of thing, but right. There's still child channels.

426
00:46:38.730 --> 00:46:46.289
Events still flow on the child channels. We'll work out the details and flow control and how do we do some initialization optimizations but.

427
00:46:46.289 --> 00:46:50.880
I think you're right, Eric, it's, it's not like, you know, totally different paradigm. We're introduced.

428
00:46:50.880 --> 00:46:55.590
I think the, the more fundamental change, the buffer stuff actually.

429
00:46:55.590 --> 00:47:01.829
Like, you know, like, um, I mean, in in an ideal world, like, the buffer would not be reference counted anymore.

430
00:47:01.829 --> 00:47:07.889
Because, I mean, as you all know, it's pretty painful and it's hard to get right?

431
00:47:07.889 --> 00:47:12.480
So, there's hope that we may be able to get rid of that.

432
00:47:12.480 --> 00:47:20.909
So, we'll see for it because buffers are so painful. I'd really like to see that get back ported as a Shim and 4 dot 1.

433
00:47:20.909 --> 00:47:29.670
So that you can upgrade or something like that. I actually know we are going to maybe do the Shim the opposite way. Maybe ship to the old and the.

434
00:47:29.670 --> 00:47:41.699
In 5.0, but 1 way or the other, we're really going to need something like that. And there's a couple of other APIs where just adding the new API to 41 or something like that. It's.

435
00:47:41.699 --> 00:47:46.289
Doesn't have to be as good as good a performance or other things that.

436
00:47:46.289 --> 00:47:50.579
You know, W, we'll gain and 5, but, um, will will help.

437
00:47:50.695 --> 00:48:05.125
Migrating without writing and speaking for followed 1. uh, let's say 95 is released in September. Uh, how long do you plan to support for 1?

438
00:48:07.380 --> 00:48:15.630
I guess that's a good question. I mean, we don't yeah, we don't know for sure yet, but I would say, at least a few years, I guess, is the right 1.

439
00:48:15.630 --> 00:48:19.409
Because it's used so heavily, I think we have no choice. Other than that.

440
00:48:19.409 --> 00:48:26.340
Um, but, yeah, definitely I mean, it will not go away for at least like 12 years for sure.

441
00:48:26.340 --> 00:48:36.269
The changes frequency would reduce dot 1 essentially. Yeah. Which which, I think is also a good thing because, I mean, that also means that it's it's.

442
00:48:36.269 --> 00:48:42.960
Less likely to get 3 questions there and make it more stable because, I mean, the reality is that it won't be a very lax.

443
00:48:42.960 --> 00:48:45.835
And what we merged into for that 1 and whatnot.

444
00:48:46.465 --> 00:48:58.554
And, um, I think, um, once we are, once we are ready with 50 to have, like, the 1st, like, alpha or whatever we should, we should be much more strict about what gets big port and whatnot.

445
00:48:59.400 --> 00:49:02.789
Right. Which would also help to, um.

446
00:49:02.789 --> 00:49:11.010
They have people upgrade, right? They need they want to have a new features so they need to upgrade and, um, for all the others, it's basically more about like.

447
00:49:11.010 --> 00:49:20.400
Correctness I would say the same as, you know, I mean, maybe if there's some, something super, super important, maybe we will back port it, but there's no guarantee.

448
00:49:20.400 --> 00:49:25.409
If it's not a bug fix, basically the same as for, for example, or whatever.

449
00:49:25.409 --> 00:49:29.400
Kind of projects you, you're talking about.

450
00:49:29.400 --> 00:49:34.980
All right.

451
00:49:36.119 --> 00:49:40.230
We are 10 minutes over. I'm happy to stay back if we have more questions.

452
00:49:41.909 --> 00:49:49.500
There any action items for people on the call uh, it sounds like you're looking for people to be early adopters of.

453
00:49:49.500 --> 00:49:57.690
95, starting on February, anything else definitely like review the fear. That will be super. Yeah. To give feedback.

454
00:49:59.489 --> 00:50:13.139
The action items that I've captured here is circling back with, like, encoder and flow controller on the child channel. Um, you know, Eric is a stakeholder interested in that and we'll drive that discussion also some questions about protocol upgrades. Um.

455
00:50:13.139 --> 00:50:21.059
Like, supporting, or not. What about web sockets? We need to do some investigation there. Um, so those are action items that have captured.

456
00:50:21.059 --> 00:50:28.050
On our end, but yeah, certainly everybody take a look at the PR, take a look at the examples. If you have feedback.

457
00:50:28.050 --> 00:50:31.199
Definitely to us.

458
00:50:31.199 --> 00:50:43.380
Yeah, also about the new buff API if you, if you didn't have a chance yet to look at it. I mean, it's also like a big change as well.

459
00:50:43.380 --> 00:50:47.519
The the next minute could be about the new.

460
00:50:50.789 --> 00:51:01.349
Happy to discuss that we had a meet up previously and we can share the content from that. Um, but, yeah, if there's more questions, if people have started to, like, pick it up with with more earnest.

461
00:51:01.349 --> 00:51:08.070
And, yeah, happy to discuss that what we can do is probably capture that wiki and.

462
00:51:08.070 --> 00:51:18.750
Uh, list of topics that people are interested in, and, you know, maybe we can drive content based on that. I think the buffer API changed quite a bit based on that last meeting. We had. So, um.

463
00:51:18.750 --> 00:51:23.670
You might want to just go to the repo.

464
00:51:23.670 --> 00:51:27.780
Again, because there were some substantial, uh, simplifications and.

465
00:51:27.780 --> 00:51:33.119
Tweaks and things have different names now than they did before, even though the the same thing.

466
00:51:33.119 --> 00:51:36.659
Um, so I'm, I'm not sure if if looking at the old.

467
00:51:36.659 --> 00:51:40.079
Slides will confuse me more or help you more.

468
00:51:40.079 --> 00:51:44.730
And maybe, at least some of the more introductory slides would still be helpful.

469
00:51:44.730 --> 00:51:48.510
That's good. Good.

470
00:51:50.460 --> 00:52:01.679
Plan for to.

471
00:52:03.420 --> 00:52:07.349
Issue we can't hear you. Could you be a little louder.

472
00:52:07.349 --> 00:52:14.250
So, what I'm saying, do we have plans to release 3 in the release.

473
00:52:15.690 --> 00:52:27.570
Ah, good question, like, normal what do you feel? Um, I mean, I think, I mean, what we talked to, what we talked about before, uh, in terms of 95, is that we want to have for, like, uh.

474
00:52:27.570 --> 00:52:34.260
Good luck and and, um, they decide what should be in the core, um, repository and what should not.

475
00:52:34.260 --> 00:52:44.340
And I think this question goes in line with that. So, at the moment is probably most of, you know, I mean, any kind of.

476
00:52:44.340 --> 00:52:50.730
Over the last few years and, um, I think as of today, I mean.

477
00:52:50.730 --> 00:53:01.920
We accepted maybe a little bit too much code in terms of we have a lot of codex there that are not widely used and maybe not as good maintain that the others in terms of code quality and all that kind of stuff.

478
00:53:01.920 --> 00:53:16.320
So would like to have, like, a hard look and decide what exactly should be in the core and whatnot, which doesn't mean that we don't support it but to also allow to give, like, different, um, release strategies.

479
00:53:16.320 --> 00:53:20.309
To some extent, or let that stuff bake a little bit more.

480
00:53:20.309 --> 00:53:26.849
Before we merge it, so I think, um, is definitely an interesting, um.

481
00:53:26.849 --> 00:53:33.780
Topic for, especially because more and more people will use it.

482
00:53:33.780 --> 00:53:37.019
I'm just not sure if it will live in the corps or not.

483
00:53:37.019 --> 00:53:44.400
Probably it will, because, I mean, H1, H2 day, 3, I guess these are like, what you standards, but.

484
00:53:44.400 --> 00:53:49.110
All right. I was very good.

485
00:53:49.110 --> 00:53:53.340
Yeah, the moment it depends on 84 1. all right.

486
00:53:53.340 --> 00:54:01.530
Um, yeah, uh, so do you plan to make it dependent on on 95 or.

487
00:54:01.530 --> 00:54:08.880
We will so, I mean, we will definitely have 1, 4, 5 0.

488
00:54:08.880 --> 00:54:12.150
That depends on on these APIs.

489
00:54:12.150 --> 00:54:16.559
I guess it's more the question if the code will be merged into the main repository or not.

490
00:54:25.559 --> 00:54:37.889
And also, maybe maybe something, which is not super related to the whole H2 thing, but I think we definitely should also merge the TC, native bits into the main branch of, to make it easier.

491
00:54:37.889 --> 00:54:42.690
To release their cell stuff and don't have any mismatches and all that kind of stuff.

492
00:54:50.730 --> 00:54:57.480
Okay all right.

493
00:54:57.480 --> 00:55:01.679
More questions, concerns commands.

494
00:55:07.260 --> 00:55:14.940
All right. Okay, cool. So, like, I think, I mean, we'll, we'll share the recording. We'll hear the slides.

495
00:55:14.940 --> 00:55:19.170
The, the action items exist and figure out how to do.

496
00:55:19.170 --> 00:55:23.340
Figure out how to how to start the monthly monthly meet ups.

497
00:55:24.719 --> 00:55:28.710
Thank you everyone for joining and again sorry for the initial.

498
00:55:28.710 --> 00:55:39.143
Communication everybody thanks a lot. Yeah, bye. Thank you. Thanks everyone for joining you take care. Bye. Bye. Bye. Bye.

