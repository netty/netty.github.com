<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Netty.docs: Reference counted objects</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<link href="../images/favicon.ico" rel="shortcut icon">
<link href="//feeds.feedburner.com/netty_project" rel="alternate" title="News Feed" type="application/rss+xml">
<style>
  body {
    padding-top: 60px;
  }
</style>
<link href="//netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" media="screen" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" media="screen" rel="stylesheet" type="text/css">
<script src="../lib/sh/scripts/shCore.js" type="text/javascript"></script>
<script src="../lib/sh/scripts/shBrushXml.js" type="text/javascript"></script>
<link href="../lib/sh/styles/shCore.css" rel="stylesheet" type="text/css">
<link href="../lib/sh/styles/shThemeDefault.css" rel="stylesheet" type="text/css">
<link href="../lib/common.css" rel="stylesheet" type="text/css">
<script src="../lib/common.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.js" type="text/javascript"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.3.0/respond.js" type="text/javascript"></script>
<![endif]-->
</head>
<body>
<a class="sr-only" href="#content" id="top">Skip navigation</a>
<nav class="navbar navbar-default navbar-fixed-top hidden-print" id="header" role="navigation">
<div class="container">
<div class="navbar-header">
<button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a class="navbar-brand" href="../index.html">
<span class="navbar-brand-logo"></span>
Netty project
</a>
</div>
<div class="navbar-collapse collapse">
<ul class="nav navbar-nav">
<li class="dropdown">
<a href="../news/2025/07/16/4-1-123-Final.html">
News
</a>
<ul class="dropdown-menu">
<li>
<a href="../news/index.html">
<i class="fa fa-archive"></i>
Archive
</a>
</li>
</ul>
</li>
<li class="dropdown">
<a href="../downloads.html">
Downloads
</a>
<ul class="dropdown-menu">
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-5.0.0.Alpha5.tar.gz">
<i class="fa fa-cloud-download"></i>
5.0.0.Alpha5
<small>&dash; 28-Sep-2022</small>
</a>
</li>
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-4.2.3.Final.tar.gz">
<i class="fa fa-cloud-download"></i>
4.2.3.Final
<small>&dash; 15-Jul-2025</small>
</a>
</li>
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-4.1.123.Final.tar.gz">
<i class="fa fa-cloud-download"></i>
4.1.123.Final
<small>&dash; 16-Jul-2025</small>
</a>
</li>
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-4.0.56.Final.tar.gz">
<i class="fa fa-cloud-download"></i>
4.0.56.Final
<small>&dash; 05-Feb-2018</small>
</a>
</li>
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-3.10.6.Final.tar.gz">
<i class="fa fa-cloud-download"></i>
3.10.6.Final
<small>&dash; 29-Jun-2016</small>
</a>
</li>
<li>
<a href="https://www.tldrlegal.com/l/APACHE2">
<i class="fa fa-gavel"></i>
Apache License 2.0
</a>
</li>
<li>
<a href="https://github.com/netty/netty/releases">
<i class="fa fa-archive"></i>
Previous Releases
</a>
</li>
<li>
<a href="https://oss.sonatype.org/content/repositories/snapshots/io/netty/">
<i class="fa fa-flask"></i>
Nightly Builds
</a>
</li>
</ul>
</li>
<li class="dropdown">
<a href="../wiki/index.html">
Documentation
</a>
<ul class="dropdown-menu">
<li>
<a href="../wiki/user-guide.html">
<i class="fa fa-book"></i>
User guide
</a>
</li>
<li>
<a href="../5.0/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 5.0
</a>
</li>
<li>
<a href="../4.2/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 4.2
</a>
</li>
<li>
<a href="../4.1/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 4.1
</a>
</li>
<li>
<a href="../4.0/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 4.0
</a>
</li>
<li>
<a href="../3.10/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 3.10
</a>
</li>
<li>
<a href="../wiki/all-documents.html">
<i class="fa fa-list"></i>
All Documents
</a>
</li>
<li>
<a href="../wiki/related-articles.html">
<i class="fa fa-bookmark"></i>
Related Articles
</a>
</li>
<li class="hidden-xs" id="bookpromo-dropdown">
<a href="https://www.manning.com/maurer/">
<img src="../images/netty-in-action.gif">
<br>
<small>
Use code <strong>mlnettyco</strong>
<br>
for a 37% discount!
</small>
</a>
</li>
</ul>
</li>
<li class="dropdown">
<a href="../community.html">
Get Involved
</a>
<ul class="dropdown-menu">
<li>
<a href="https://github.com/netty/netty">
<i class="fa fa-github-square"></i>
Github
</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/tagged/netty">
<i class="fa fa-stack-overflow"></i>
StackOverflow
</a>
</li>
<li>
<a href="https://twitter.com/netty_project">
<i class="fa fa-twitter-square"></i>
@netty_project
</a>
</li>
<li>
<a href="../wiki/developer-guide.html">
<i class="fa fa-cogs"></i>
Developer Guide
</a>
</li>
<li>
<a href="https://discord.gg/GkGzzdQM5d">
<i class="fa fa-comment"></i>
Discord Server
</a>
</li>
<li>
<a href="../sponsor/thanks.html">
<i class="fa fa-usd"></i>
Sponsors
</a>
</li>
<li>
<a href="../wiki/adopters.html">
<i class="fa fa-users"></i>
Adopters
</a>
</li>
<li>
<a href="../wiki/related-projects.html">
<i class="fa fa-chain"></i>
Related Projects
</a>
</li>
</ul>
</li>
<li class="visible-xs" id="bookpromo-nav">
<a href="https://www.manning.com/maurer/">
<img src="../images/netty-in-action.gif">
<br>
<small>
Use code <strong>mlnettyco</strong>
<br>
for a 37% discount!
</small>
</a>
</li>
<li>
<a href="https://feeds.feedburner.com/netty_project">
<i class="fa fa-rss"></i>
</a>
</li>
</ul>
<form action="../search.html" class="navbar-form navbar-right hidden-sm" method="GET" onsubmit="return validateGlobalSearchQuery()" role="search">
<div class="form-group">
<input class="search-query form-control" id="global-search-query" name="q" placeholder="Search" type="text">
</div>
</form>
</div>
</div>
</nav>
<div id="content">
<div class="container">
<div class="wiki-item">
<h1>Reference counted objects</h1>
<div class="alert alert-info">
Did you know this page is automatically generated from
<a href="https://github.com/netty/netty/wiki/Reference-counted-objects">a Github Wiki page?</a>
You can improve it by yourself
<a href="https://github.com/netty/netty/wiki/Reference-counted-objects">here!</a>
</div>
<div class="row">
<div class="col-md-9">
<div id="wiki-body" class="gollum-markdown-content">
              <div class="markdown-body">
                <p>Since Netty version 4, the life cycle of certain objects are managed by their reference counts, so that Netty can return them (or their shared resources) to an object pool (or an object allocator) as soon as it is not used anymore.  Garbage collection and reference queues do not provide efficient real-time guarantee of unreachability, while reference-counting provides an alternative mechanism at the cost of slight inconvenience.</p>
<p><a href="http://netty.io/4.0/api/index.html?io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a> is the most notable type taking advantage of reference counting to improve the allocation and deallocation performance, and this page will explain how reference counting in Netty works using <code>ByteBuf</code>.</p>
<div class="markdown-heading">
<h2 class="heading-element" id="wiki-h2-0">Basics of reference counting</h2>
<a id="user-content-basics-of-reference-counting" class="anchor" aria-label="Permalink: Basics of reference counting" href="#basics-of-reference-counting"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>The initial reference count of a reference-counted object is 1:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="ByteBuf buf = ctx.alloc().directBuffer();
assert buf.refCnt() == 1;"><pre><span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">directBuffer</span>();&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">1</span>;</pre></div>
<p>When you release the reference-counted object, its reference count is decreased by 1.  If the reference count reaches 0, the reference-counted object is deallocated or returned to the object pool it came from:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="assert buf.refCnt() == 1;
// release() returns true only if the reference count becomes 0.
boolean destroyed = buf.release();
assert destroyed;
assert buf.refCnt() == 0;"><pre><span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">1</span>;&#x000A;<span class="pl-c">// release() returns true only if the reference count becomes 0.</span>&#x000A;<span class="pl-smi">boolean</span> <span class="pl-s1">destroyed</span> = <span class="pl-s1">buf</span>.<span class="pl-en">release</span>();&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">destroyed</span>;&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">0</span>;</pre></div>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-1">Dangling reference</h3>
<a id="user-content-dangling-reference" class="anchor" aria-label="Permalink: Dangling reference" href="#dangling-reference"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>Attempting to access the reference-counted object, whose reference count is 0, will trigger an <code>IllegalReferenceCountException</code>:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content='assert buf.refCnt() == 0;
try {
  buf.writeLong(0xdeadbeef);
  throw new Error("should not reach here");
} catch (IllegalReferenceCountExeception e) {
  // Expected
}'><pre><span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">0</span>;&#x000A;<span class="pl-k">try</span> {&#x000A;  <span class="pl-s1">buf</span>.<span class="pl-en">writeLong</span>(<span class="pl-c1">0xdeadbeef</span>);&#x000A;  <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-smi">Error</span>(<span class="pl-s">"should not reach here"</span>);&#x000A;} <span class="pl-k">catch</span> (<span class="pl-smi">IllegalReferenceCountExeception</span> <span class="pl-s1">e</span>) {&#x000A;  <span class="pl-c">// Expected</span>&#x000A;}</pre></div>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-2">Increasing the reference count</h3>
<a id="user-content-increasing-the-reference-count" class="anchor" aria-label="Permalink: Increasing the reference count" href="#increasing-the-reference-count"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>A reference count can also be incremented via the <code>retain()</code> operation, as long as it is not yet destroyed:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="ByteBuf buf = ctx.alloc().directBuffer();
assert buf.refCnt() == 1;

buf.retain();
assert buf.refCnt() == 2;

boolean destroyed = buf.release();
assert !destroyed;
assert buf.refCnt() == 1;"><pre><span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">directBuffer</span>();&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">1</span>;&#x000A;&#x000A;<span class="pl-s1">buf</span>.<span class="pl-en">retain</span>();&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">2</span>;&#x000A;&#x000A;<span class="pl-smi">boolean</span> <span class="pl-s1">destroyed</span> = <span class="pl-s1">buf</span>.<span class="pl-en">release</span>();&#x000A;<span class="pl-k">assert</span> !<span class="pl-s1">destroyed</span>;&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">1</span>;</pre></div>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-3">Who destroys it?</h3>
<a id="user-content-who-destroys-it" class="anchor" aria-label="Permalink: Who destroys it?" href="#who-destroys-it"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>The general rule of thumb is that the party that accesses a reference-counted object last is also responsible for the destruction of that reference-counted object. Specifically:</p>
<ul>
<li>If a [sending] component is supposed to pass a reference-counted object to another [receiving] component, the sending component usually does not need to destroy it but defers that decision to the receiving component.</li>
<li>If a component consumes a reference-counted object and knows nothing else will access it anymore (i.e., does not pass along a reference to yet another component), the component should destroy it.</li>
</ul>
<p>Here is a simple example:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="public ByteBuf a(ByteBuf input) {
    input.writeByte(42);
    return input;
}

public ByteBuf b(ByteBuf input) {
    try {
        output = input.alloc().directBuffer(input.readableBytes() + 1);
        output.writeBytes(input);
        output.writeByte(42);
        return output;
    } finally {
        input.release();
    }
}

public void c(ByteBuf input) {
    System.out.println(input);
    input.release();
}

public void main() {
    ...
    ByteBuf buf = ...;
    // This will print buf to System.out and destroy it.
    c(b(a(buf)));
    assert buf.refCnt() == 0;
}"><pre><span class="pl-k">public</span> <span class="pl-smi">ByteBuf</span> <span class="pl-en">a</span>(<span class="pl-smi">ByteBuf</span> <span class="pl-s1">input</span>) {&#x000A;    <span class="pl-s1">input</span>.<span class="pl-en">writeByte</span>(<span class="pl-c1">42</span>);&#x000A;    <span class="pl-k">return</span> <span class="pl-s1">input</span>;&#x000A;}&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-smi">ByteBuf</span> <span class="pl-en">b</span>(<span class="pl-smi">ByteBuf</span> <span class="pl-s1">input</span>) {&#x000A;    <span class="pl-k">try</span> {&#x000A;        <span class="pl-s1">output</span> = <span class="pl-s1">input</span>.<span class="pl-en">alloc</span>().<span class="pl-en">directBuffer</span>(<span class="pl-s1">input</span>.<span class="pl-en">readableBytes</span>() + <span class="pl-c1">1</span>);&#x000A;        <span class="pl-s1">output</span>.<span class="pl-en">writeBytes</span>(<span class="pl-s1">input</span>);&#x000A;        <span class="pl-s1">output</span>.<span class="pl-en">writeByte</span>(<span class="pl-c1">42</span>);&#x000A;        <span class="pl-k">return</span> <span class="pl-s1">output</span>;&#x000A;    } <span class="pl-k">finally</span> {&#x000A;        <span class="pl-s1">input</span>.<span class="pl-en">release</span>();&#x000A;    }&#x000A;}&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">c</span>(<span class="pl-smi">ByteBuf</span> <span class="pl-s1">input</span>) {&#x000A;    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">input</span>);&#x000A;    <span class="pl-s1">input</span>.<span class="pl-en">release</span>();&#x000A;}&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>() {&#x000A;    ...&#x000A;    <span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span> = ...;&#x000A;    <span class="pl-c">// This will print buf to System.out and destroy it.</span>&#x000A;    <span class="pl-en">c</span>(<span class="pl-en">b</span>(<span class="pl-en">a</span>(<span class="pl-s1">buf</span>)));&#x000A;    <span class="pl-k">assert</span> <span class="pl-s1">buf</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">0</span>;&#x000A;}</pre></div>
<table role="table">
<thead>
<tr>
<th>Action</th>
<th>Who should release?</th>
<th>Who released?</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. <code>main()</code> creates <code>buf</code>
</td>
<td>
<code>buf</code>→<code>main()</code>
</td>
<td></td>
</tr>
<tr>
<td>2. <code>main()</code> calls <code>a()</code> with <code>buf</code>
</td>
<td>
<code>buf</code>→<code>a()</code>
</td>
<td></td>
</tr>
<tr>
<td>3. <code>a()</code> returns <code>buf</code> merely.</td>
<td>
<code>buf</code>→<code>main()</code>
</td>
<td></td>
</tr>
<tr>
<td>4. <code>main()</code> calls <code>b()</code> with <code>buf</code>
</td>
<td>
<code>buf</code>→<code>b()</code>
</td>
<td></td>
</tr>
<tr>
<td>5. <code>b()</code> returns the copy of <code>buf</code>
</td>
<td>
<code>buf</code>→<code>b()</code>, <code>copy</code>→<code>main()</code>
</td>
<td>
<code>b()</code> releases <code>buf</code>
</td>
</tr>
<tr>
<td>6. <code>main()</code> calls <code>c()</code> with <code>copy</code>
</td>
<td>
<code>copy</code>→<code>c()</code>
</td>
<td></td>
</tr>
<tr>
<td>7. <code>c()</code> swallows <code>copy</code>
</td>
<td>
<code>copy</code>→<code>c()</code>
</td>
<td>
<code>c()</code> releases <code>copy</code>
</td>
</tr>
</tbody>
</table>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-4">Derived buffers</h3>
<a id="user-content-derived-buffers" class="anchor" aria-label="Permalink: Derived buffers" href="#derived-buffers"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p><code>ByteBuf.duplicate()</code>, <code>ByteBuf.slice()</code> and <code>ByteBuf.order(ByteOrder)</code> create a <em>derived</em> buffer which shares the memory region of the parent buffer.  A derived buffer does not have its own reference count, but shares the reference count of the parent buffer.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="ByteBuf parent = ctx.alloc().directBuffer();
ByteBuf derived = parent.duplicate();

// Creating a derived buffer does not increase the reference count.
assert parent.refCnt() == 1;
assert derived.refCnt() == 1;"><pre><span class="pl-smi">ByteBuf</span> <span class="pl-s1">parent</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">directBuffer</span>();&#x000A;<span class="pl-smi">ByteBuf</span> <span class="pl-s1">derived</span> = <span class="pl-s1">parent</span>.<span class="pl-en">duplicate</span>();&#x000A;&#x000A;<span class="pl-c">// Creating a derived buffer does not increase the reference count.</span>&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">parent</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">1</span>;&#x000A;<span class="pl-k">assert</span> <span class="pl-s1">derived</span>.<span class="pl-en">refCnt</span>() == <span class="pl-c1">1</span>;</pre></div>
<p>In contrast, <code>ByteBuf.copy()</code> and <code>ByteBuf.readBytes(int)</code> are <em>not derived</em> buffers.  The returned <code>ByteBuf</code> is allocated and will need to be released.</p>
<p>Note that a parent buffer and its derived buffers share the same reference count, and the reference count does not increase when a derived buffer is created.  Therefore, if you are going to pass a derived buffer to an other component of your application, you will have to call <code>retain()</code> on it first.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="ByteBuf parent = ctx.alloc().directBuffer(512);
parent.writeBytes(...);

try {
    while (parent.isReadable(16)) {
        ByteBuf derived = parent.readSlice(16);
        derived.retain();
        process(derived);
    }
} finally {
    parent.release();
}
...

public void process(ByteBuf buf) {
    ...
    buf.release();
}"><pre><span class="pl-smi">ByteBuf</span> <span class="pl-s1">parent</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">directBuffer</span>(<span class="pl-c1">512</span>);&#x000A;<span class="pl-s1">parent</span>.<span class="pl-en">writeBytes</span>(...);&#x000A;&#x000A;<span class="pl-k">try</span> {&#x000A;    <span class="pl-k">while</span> (<span class="pl-s1">parent</span>.<span class="pl-en">isReadable</span>(<span class="pl-c1">16</span>)) {&#x000A;        <span class="pl-smi">ByteBuf</span> <span class="pl-s1">derived</span> = <span class="pl-s1">parent</span>.<span class="pl-en">readSlice</span>(<span class="pl-c1">16</span>);&#x000A;        <span class="pl-s1">derived</span>.<span class="pl-en">retain</span>();&#x000A;        <span class="pl-en">process</span>(<span class="pl-s1">derived</span>);&#x000A;    }&#x000A;} <span class="pl-k">finally</span> {&#x000A;    <span class="pl-s1">parent</span>.<span class="pl-en">release</span>();&#x000A;}&#x000A;...&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">process</span>(<span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span>) {&#x000A;    ...&#x000A;    <span class="pl-s1">buf</span>.<span class="pl-en">release</span>();&#x000A;}</pre></div>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-5">
<code>ByteBufHolder</code> interface</h3>
<a id="user-content-bytebufholder-interface" class="anchor" aria-label="Permalink: ByteBufHolder interface" href="#bytebufholder-interface"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>Sometimes, a <code>ByteBuf</code> is contained by a buffer holder, such as <a href="http://netty.io/4.0/api/index.html?io/netty/channel/socket/DatagramPacket.html" rel="nofollow"><code>DatagramPacket</code></a>, <a href="http://netty.io/4.0/api/index.html?io/netty/handler/codec/http/HttpContent.html" rel="nofollow"><code>HttpContent</code></a>, and <a href="http://netty.io/4.0/api/index.html?io/netty/handler/codec/http/websocketx/WebSocketFrame.html" rel="nofollow"><code>WebSocketframe</code></a>.  Those types extend a common interface called <a href="http://netty.io/4.0/api/index.html?io/netty/buffer/ByteBufHolder.html" rel="nofollow"><code>ByteBufHolder</code></a>.</p>
<p>A buffer holder shares the reference count of the buffer it contains, just like a derived buffer.</p>
<div class="markdown-heading">
<h2 class="heading-element" id="wiki-h2-6">Reference-counting in <code>ChannelHandler</code>
</h2>
<a id="user-content-reference-counting-in-channelhandler" class="anchor" aria-label="Permalink: Reference-counting in ChannelHandler" href="#reference-counting-in-channelhandler"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-7">Inbound messages</h3>
<a id="user-content-inbound-messages" class="anchor" aria-label="Permalink: Inbound messages" href="#inbound-messages"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>When an event loop reads data into a <code>ByteBuf</code> and triggers a <code>channelRead()</code> event with it, it is the responsibility of the <code>ChannelHandler</code> in the corresponding pipeline to release the buffer.  Therefore, the handler that consumes the received data should call <code>release()</code> on the data in its <code>channelRead()</code> handler method:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf buf = (ByteBuf) msg;
    try {
        ...
    } finally {
        buf.release();
    }
}"><pre><span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;    <span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span> = (<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>;&#x000A;    <span class="pl-k">try</span> {&#x000A;        ...&#x000A;    } <span class="pl-k">finally</span> {&#x000A;        <span class="pl-s1">buf</span>.<span class="pl-en">release</span>();&#x000A;    }&#x000A;}</pre></div>
<p>As explained in the 'Who destroys?' section of this document, if your handler passes the buffer (or any reference-counted object) to the next handler, you don't need to release it:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf buf = (ByteBuf) msg;
    ...
    ctx.fireChannelRead(buf);
}"><pre><span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;    <span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span> = (<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>;&#x000A;    ...&#x000A;    <span class="pl-s1">ctx</span>.<span class="pl-en">fireChannelRead</span>(<span class="pl-s1">buf</span>);&#x000A;}</pre></div>
<p>Note that <code>ByteBuf</code> isn't the only reference-counted type in Netty.  If you are dealing with the messages generated by decoders, it is very likely that the message is also reference-counted:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="// Assuming your handler is placed next to `HttpRequestDecoder`
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    if (msg instanceof HttpRequest) {
        HttpRequest req = (HttpRequest) msg;
        ...
    }
    if (msg instanceof HttpContent) {
        HttpContent content = (HttpContent) msg;
        try {
            ...
        } finally {
            content.release();
        }
    }
}"><pre><span class="pl-c">// Assuming your handler is placed next to `HttpRequestDecoder`</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;    <span class="pl-k">if</span> (<span class="pl-s1">msg</span> <span class="pl-k">instanceof</span> <span class="pl-smi">HttpRequest</span>) {&#x000A;        <span class="pl-smi">HttpRequest</span> <span class="pl-s1">req</span> = (<span class="pl-smi">HttpRequest</span>) <span class="pl-s1">msg</span>;&#x000A;        ...&#x000A;    }&#x000A;    <span class="pl-k">if</span> (<span class="pl-s1">msg</span> <span class="pl-k">instanceof</span> <span class="pl-smi">HttpContent</span>) {&#x000A;        <span class="pl-smi">HttpContent</span> <span class="pl-s1">content</span> = (<span class="pl-smi">HttpContent</span>) <span class="pl-s1">msg</span>;&#x000A;        <span class="pl-k">try</span> {&#x000A;            ...&#x000A;        } <span class="pl-k">finally</span> {&#x000A;            <span class="pl-s1">content</span>.<span class="pl-en">release</span>();&#x000A;        }&#x000A;    }&#x000A;}</pre></div>
<p>If you are in doubt or you want to simplify releasing the messages, you can use <code>ReferenceCountUtil.release()</code>:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="public void channelRead(ChannelHandlerContext ctx, Object msg) {
    try {
        ...
    } finally {
        ReferenceCountUtil.release(msg);
    }
}"><pre><span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;    <span class="pl-k">try</span> {&#x000A;        ...&#x000A;    } <span class="pl-k">finally</span> {&#x000A;        <span class="pl-smi">ReferenceCountUtil</span>.<span class="pl-en">release</span>(<span class="pl-s1">msg</span>);&#x000A;    }&#x000A;}</pre></div>
<p>Alternatively, you could consider extending <code>SimpleChannelHandler</code> which calls <code>ReferenceCountUtil.release(msg)</code> for all messages you receive.</p>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-8">Outbound messages</h3>
<a id="user-content-outbound-messages" class="anchor" aria-label="Permalink: Outbound messages" href="#outbound-messages"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>Unlike inbound messages, outbound messages are created by your application, and it is the responsibility of Netty to release these after writing them out to the wire.  However, the handlers that intercept your write requests should make sure to release any intermediary objects properly. (e.g. encoders)</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content='// Simple-pass through
public void write(ChannelHandlerContext ctx, Object message, ChannelPromise promise) {
    System.err.println("Writing: " + message);
    ctx.write(message, promise);
}

// Transformation
public void write(ChannelHandlerContext ctx, Object message, ChannelPromise promise) {
    if (message instanceof HttpContent) {
        // Transform HttpContent to ByteBuf.
        HttpContent content = (HttpContent) message;
        try {
            ByteBuf transformed = ctx.alloc().buffer();
            ....
            ctx.write(transformed, promise);
        } finally {
            content.release();
        }
    } else {
        // Pass non-HttpContent through.
        ctx.write(message, promise);
    }
}'><pre><span class="pl-c">// Simple-pass through</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">write</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">message</span>, <span class="pl-smi">ChannelPromise</span> <span class="pl-s1">promise</span>) {&#x000A;    <span class="pl-smi">System</span>.<span class="pl-s1">err</span>.<span class="pl-en">println</span>(<span class="pl-s">"Writing: "</span> + <span class="pl-s1">message</span>);&#x000A;    <span class="pl-s1">ctx</span>.<span class="pl-en">write</span>(<span class="pl-s1">message</span>, <span class="pl-s1">promise</span>);&#x000A;}&#x000A;&#x000A;<span class="pl-c">// Transformation</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">write</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">message</span>, <span class="pl-smi">ChannelPromise</span> <span class="pl-s1">promise</span>) {&#x000A;    <span class="pl-k">if</span> (<span class="pl-s1">message</span> <span class="pl-k">instanceof</span> <span class="pl-smi">HttpContent</span>) {&#x000A;        <span class="pl-c">// Transform HttpContent to ByteBuf.</span>&#x000A;        <span class="pl-smi">HttpContent</span> <span class="pl-s1">content</span> = (<span class="pl-smi">HttpContent</span>) <span class="pl-s1">message</span>;&#x000A;        <span class="pl-k">try</span> {&#x000A;            <span class="pl-smi">ByteBuf</span> <span class="pl-s1">transformed</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">buffer</span>();&#x000A;            ....&#x000A;            <span class="pl-s1">ctx</span>.<span class="pl-en">write</span>(<span class="pl-s1">transformed</span>, <span class="pl-s1">promise</span>);&#x000A;        } <span class="pl-k">finally</span> {&#x000A;            <span class="pl-s1">content</span>.<span class="pl-en">release</span>();&#x000A;        }&#x000A;    } <span class="pl-k">else</span> {&#x000A;        <span class="pl-c">// Pass non-HttpContent through.</span>&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">write</span>(<span class="pl-s1">message</span>, <span class="pl-s1">promise</span>);&#x000A;    }&#x000A;}</pre></div>
<div class="markdown-heading">
<h2 class="heading-element" id="wiki-h2-9">Troubleshooting buffer leaks</h2>
<a id="user-content-troubleshooting-buffer-leaks" class="anchor" aria-label="Permalink: Troubleshooting buffer leaks" href="#troubleshooting-buffer-leaks"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>The disadvantage of reference counting is that it is easy to leak the reference-counted objects.  Because the JVM is not aware of the reference counting Netty implements, it will automatically garbage collect them once they become unreachable, even if their reference counts are not zero. An object cannot be resurrected once garbage collected, and thus cannot be returned to the pool it came from and thus will produce a memory leak.</p>
<p>Fortunately, despite the difficulty of finding leaks, Netty will by default sample about 1% of buffer allocations to check if there is a leak in your application.  In case of leak, you will find the following log message:</p>
<blockquote>
<p><code>LEAK: ByteBuf.release() was not called before it's garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option '-Dio.netty.leakDetectionLevel=advanced' or call ResourceLeakDetector.setLevel()</code></p>
</blockquote>
<p>Relaunch your application with the JVM option mentioned above and  you will see the recent locations of your application where the leaked buffer was accessed.  The following output shows a leak from our unit test (<code>XmlFrameDecoderTest.testDecodeWithXml()</code>):</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Running io.netty.handler.codec.xml.XmlFrameDecoderTest
15:03:36.886 [main] ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected.
Recent access records: 1
#1:
	io.netty.buffer.AdvancedLeakAwareByteBuf.toString(AdvancedLeakAwareByteBuf.java:697)
	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithXml(XmlFrameDecoderTest.java:157)
	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithTwoMessages(XmlFrameDecoderTest.java:133)
	...

Created at:
	io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:55)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)
	io.netty.buffer.UnpooledUnsafeDirectByteBuf.copy(UnpooledUnsafeDirectByteBuf.java:465)
	io.netty.buffer.WrappedByteBuf.copy(WrappedByteBuf.java:697)
	io.netty.buffer.AdvancedLeakAwareByteBuf.copy(AdvancedLeakAwareByteBuf.java:656)
	io.netty.handler.codec.xml.XmlFrameDecoder.extractFrame(XmlFrameDecoder.java:198)
	io.netty.handler.codec.xml.XmlFrameDecoder.decode(XmlFrameDecoder.java:174)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:227)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:140)
	io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:74)
	io.netty.channel.embedded.EmbeddedEventLoop.invokeChannelRead(EmbeddedEventLoop.java:142)
	io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:317)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
	io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:176)
	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithXml(XmlFrameDecoderTest.java:147)
	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithTwoMessages(XmlFrameDecoderTest.java:133)
	..."><pre class="notranslate"><code>Running io.netty.handler.codec.xml.XmlFrameDecoderTest&#x000A;15:03:36.886 [main] ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected.&#x000A;Recent access records: 1&#x000A;#1:&#x000A;	io.netty.buffer.AdvancedLeakAwareByteBuf.toString(AdvancedLeakAwareByteBuf.java:697)&#x000A;	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithXml(XmlFrameDecoderTest.java:157)&#x000A;	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithTwoMessages(XmlFrameDecoderTest.java:133)&#x000A;	...&#x000A;&#x000A;Created at:&#x000A;	io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:55)&#x000A;	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)&#x000A;	io.netty.buffer.UnpooledUnsafeDirectByteBuf.copy(UnpooledUnsafeDirectByteBuf.java:465)&#x000A;	io.netty.buffer.WrappedByteBuf.copy(WrappedByteBuf.java:697)&#x000A;	io.netty.buffer.AdvancedLeakAwareByteBuf.copy(AdvancedLeakAwareByteBuf.java:656)&#x000A;	io.netty.handler.codec.xml.XmlFrameDecoder.extractFrame(XmlFrameDecoder.java:198)&#x000A;	io.netty.handler.codec.xml.XmlFrameDecoder.decode(XmlFrameDecoder.java:174)&#x000A;	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:227)&#x000A;	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:140)&#x000A;	io.netty.channel.ChannelHandlerInvokerUtil.invokeChannelReadNow(ChannelHandlerInvokerUtil.java:74)&#x000A;	io.netty.channel.embedded.EmbeddedEventLoop.invokeChannelRead(EmbeddedEventLoop.java:142)&#x000A;	io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:317)&#x000A;	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)&#x000A;	io.netty.channel.embedded.EmbeddedChannel.writeInbound(EmbeddedChannel.java:176)&#x000A;	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithXml(XmlFrameDecoderTest.java:147)&#x000A;	io.netty.handler.codec.xml.XmlFrameDecoderTest.testDecodeWithTwoMessages(XmlFrameDecoderTest.java:133)&#x000A;	...&#x000A;</code></pre></div>
<p>If you use Netty 5 or above, an additional information is provided to help you find which handler handled the leaked buffer lastly.  The following example shows that the leaked buffer was handled by the handler whose name is <code>EchoServerHandler#0</code> and then garbage-collected, which means it is likely that <code>EchoServerHandler#0</code> forgot to release the buffer:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="12:05:24.374 [nioEventLoop-1-1] ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected.
Recent access records: 2
#2:
	Hint: 'EchoServerHandler#0' will handle the message from this point.
	io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:329)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:133)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:485)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346)
	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:794)
	java.lang.Thread.run(Thread.java:744)
#1:
	io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:589)
	io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:208)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:125)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:485)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346)
	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:794)
	java.lang.Thread.run(Thread.java:744)
Created at:
	io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:55)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:146)
	io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:107)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:485)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346)
	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:794)
	java.lang.Thread.run(Thread.java:744)"><pre class="notranslate"><code>12:05:24.374 [nioEventLoop-1-1] ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected.&#x000A;Recent access records: 2&#x000A;#2:&#x000A;	Hint: 'EchoServerHandler#0' will handle the message from this point.&#x000A;	io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:329)&#x000A;	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:846)&#x000A;	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:133)&#x000A;	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:485)&#x000A;	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452)&#x000A;	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346)&#x000A;	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:794)&#x000A;	java.lang.Thread.run(Thread.java:744)&#x000A;#1:&#x000A;	io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:589)&#x000A;	io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:208)&#x000A;	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:125)&#x000A;	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:485)&#x000A;	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452)&#x000A;	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346)&#x000A;	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:794)&#x000A;	java.lang.Thread.run(Thread.java:744)&#x000A;Created at:&#x000A;	io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:55)&#x000A;	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)&#x000A;	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:146)&#x000A;	io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:107)&#x000A;	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)&#x000A;	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:485)&#x000A;	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452)&#x000A;	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346)&#x000A;	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:794)&#x000A;	java.lang.Thread.run(Thread.java:744)&#x000A;</code></pre></div>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-10">Leak detection levels</h3>
<a id="user-content-leak-detection-levels" class="anchor" aria-label="Permalink: Leak detection levels" href="#leak-detection-levels"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>There are currently 4 levels of leak detection:</p>
<ul>
<li>
<code>DISABLED</code> - disables leak detection completely. Not recommended.</li>
<li>
<code>SIMPLE</code> - tells if there is a leak or not for 1% of buffers. Default.</li>
<li>
<code>ADVANCED</code> - tells where the leaked buffer was accessed for 1% of buffers.</li>
<li>
<code>PARANOID</code> - Same with <code>ADVANCED</code> except that it's for every single buffer.  Useful for automated testing phase. You could fail the build if the build output contains '<code>LEAK: </code>'.</li>
</ul>
<p>You can specify the leak detection level as a JVM option <code>-Dio.netty.leakDetection.level</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="java -Dio.netty.leakDetection.level=advanced ..."><pre class="notranslate"><code>java -Dio.netty.leakDetection.level=advanced ...&#x000A;</code></pre></div>
<p><strong>NOTE</strong>: This property used to be called <code>io.netty.leakDetectionLevel</code>.</p>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-11">Best practices to avoid leaks</h3>
<a id="user-content-best-practices-to-avoid-leaks" class="anchor" aria-label="Permalink: Best practices to avoid leaks" href="#best-practices-to-avoid-leaks"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<ul>
<li>Run your unit tests and integration tests at <code>PARANOID</code> leak detection level, as well as at <code>SIMPLE</code> level.</li>
<li>Canary your application before rolling out to the entire cluster at <code>SIMPLE</code> level for a reasonably long time to see if there's a leak.</li>
<li>If there is a leak, canary again at <code>ADVANCED</code> level to get some hints about where the leak is coming from.</li>
<li>Do not deploy an application with a leak to the entire cluster.</li>
</ul>
<div class="markdown-heading">
<h3 class="heading-element" id="wiki-h3-12">Fixing leaks in unit tests</h3>
<a id="user-content-fixing-leaks-in-unit-tests" class="anchor" aria-label="Permalink: Fixing leaks in unit tests" href="#fixing-leaks-in-unit-tests"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>
</div>
<p>It is very easy to forget to release a buffer or a message in a unit test.  It will generate a leak warning, but it does not necessarily mean that your application has a leak.  Instead of wrapping your unit tests with <code>try-finally</code> blocks to release all buffers, you can use <code>ReferenceCountUtil.releaseLater()</code> utility method:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="import static io.netty.util.ReferenceCountUtil.*;

@Test
public void testSomething() throws Exception {
    // ReferenceCountUtil.releaseLater() will keep the reference of buf,
    // and then release it when the test thread is terminated.
    ByteBuf buf = releaseLater(Unpooled.directBuffer(512));
    ...
}"><pre><span class="pl-k">import</span> <span class="pl-k">static</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">util</span>.<span class="pl-s1">ReferenceCountUtil</span>.*;&#x000A;&#x000A;<span class="pl-c1">@</span><span class="pl-c1">Test</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">testSomething</span>() <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {&#x000A;    <span class="pl-c">// ReferenceCountUtil.releaseLater() will keep the reference of buf,</span>&#x000A;    <span class="pl-c">// and then release it when the test thread is terminated.</span>&#x000A;    <span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span> = <span class="pl-en">releaseLater</span>(<span class="pl-smi">Unpooled</span>.<span class="pl-en">directBuffer</span>(<span class="pl-c1">512</span>));&#x000A;    ...&#x000A;}</pre></div>
<hr>
<p><strong>External Links:</strong></p>
<p><a href="http://stackoverflow.com/questions/28647048/why-do-we-need-to-manually-handle-reference-counting-for-netty-bytebuf-if-jvm-gc" rel="nofollow">Why do we need to manually handle reference counting for Netty ByteBuf if JVM GC is still in place?</a></p>
<p><a href="http://stackoverflow.com/questions/15781276/buffer-ownership-in-netty-4-how-is-buffer-life-cycle-managed" rel="nofollow">Buffer ownership in Netty 4: How is buffer life-cycle managed?</a></p>

              </div>

          </div></div>
<div class="toc-container col-md-3 hidden-xs hidden-sm hidden-print" role="complementary">
<div class="toc well">
<ul class="nav nav-list nav-stacked">
<li class="nav-header">Table of Contents
</li><li><a href="#wiki-h2-0" title="Basics of reference counting">Basics of reference counting</a>
<ul class="nav nav-list nav-stacked"><li><a href="#wiki-h3-1" title="Dangling reference">Dangling reference</a>
</li><li><a href="#wiki-h3-2" title="Increasing the reference count">Increasing the reference count</a>
</li><li><a href="#wiki-h3-3" title="Who destroys it?">Who destroys it?</a>
</li><li><a href="#wiki-h3-4" title="Derived buffers">Derived buffers</a>
</li><li><a href="#wiki-h3-5" title="ByteBufHolder interface">ByteBufHolder interface</a>
</li></ul></li><li><a href="#wiki-h2-6" title="Reference-counting in ChannelHandler">Reference-counting in ChannelHandler</a>
<ul class="nav nav-list nav-stacked"><li><a href="#wiki-h3-7" title="Inbound messages">Inbound messages</a>
</li><li><a href="#wiki-h3-8" title="Outbound messages">Outbound messages</a>
</li></ul></li><li><a href="#wiki-h2-9" title="Troubleshooting buffer leaks">Troubleshooting buffer leaks</a>
<ul class="nav nav-list nav-stacked"><li><a href="#wiki-h3-10" title="Leak detection levels">Leak detection levels</a>
</li><li><a href="#wiki-h3-11" title="Best practices to avoid leaks">Best practices to avoid leaks</a>
</li><li><a href="#wiki-h3-12" title="Fixing leaks in unit tests">Fixing leaks in unit tests</a>
</li><li><a href="#wiki-h3-13" title="Toggle table of contents

      Pages 32">Toggle table of contents

      Pages 32</a>
</li><li><a href="#wiki-h3-14" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-15" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-16" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-17" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-18" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-19" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-20" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-21" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-22" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-23" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-24" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-25" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-26" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-27" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-28" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-29" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-30" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-31" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-32" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-33" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-34" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-35" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-36" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-37" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-38" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-39" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-40" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-41" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-42" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-43" title="Uh oh!">Uh oh!</a>
</li><li><a href="#wiki-h3-44" title="Uh oh!">Uh oh!</a>
</li></ul>
</li></ul>
</div>
</div>
</div>

<div class="row">
<div class="col-md-9">
<div class="text-right">
<small>Last retrieved on 16-Jul-2025</small>
</div>
</div>
</div>
</div>

</div>

</div>
<div class="container">
<hr>
<div id="footer">
<p>
Copyright &copy; 2025
<a href="../index.html">The Netty project</a>
</p>
</div>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script>
<script src="../lib/common.footer.js" type="text/javascript"></script>

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-95307-5', 'auto');
ga('require', 'displayfeatures');
ga('require', 'linkid', 'linkid.js');
ga('send', 'pageview');
</script>
</body>
</html>
