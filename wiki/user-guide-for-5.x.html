<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Netty.docs: User guide for 5.x</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<link href="../images/favicon.ico" rel="shortcut icon">
<link href="//feeds.feedburner.com/netty_project" rel="alternate" title="News Feed" type="application/rss+xml">
<style>
  body {
    padding-top: 60px;
  }
</style>
<link href="//netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" media="screen" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" media="screen" rel="stylesheet" type="text/css">
<script src="../lib/sh/scripts/shCore.js" type="text/javascript"></script>
<script src="../lib/sh/scripts/shBrushXml.js" type="text/javascript"></script>
<link href="../lib/sh/styles/shCore.css" rel="stylesheet" type="text/css">
<link href="../lib/sh/styles/shThemeDefault.css" rel="stylesheet" type="text/css">
<link href="../lib/common.css" rel="stylesheet" type="text/css">
<script src="../lib/common.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.js" type="text/javascript"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.3.0/respond.js" type="text/javascript"></script>
<![endif]-->
</head>
<body>
<a class="sr-only" href="#content" id="top">Skip navigation</a>
<nav class="navbar navbar-default navbar-fixed-top hidden-print" id="header" role="navigation">
<div class="container">
<div class="navbar-header">
<button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a class="navbar-brand" href="../index.html">
<span class="navbar-brand-logo"></span>
Netty project
</a>
</div>
<div class="navbar-collapse collapse">
<ul class="nav navbar-nav">
<li class="dropdown">
<a href="../news/2024/01/23/ohttp-0-0-5-Final.html">
News
</a>
<ul class="dropdown-menu">
<li>
<a href="../news/index.html">
<i class="fa fa-archive"></i>
Archive
</a>
</li>
</ul>
</li>
<li class="dropdown">
<a href="../downloads.html">
Downloads
</a>
<ul class="dropdown-menu">
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-5.0.0.Alpha5.tar.gz">
<i class="fa fa-cloud-download"></i>
5.0.0.Alpha5
<small>&dash; 28-Sep-2022</small>
</a>
</li>
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-4.1.105.Final.tar.gz">
<i class="fa fa-cloud-download"></i>
4.1.105.Final
<small>&dash; 16-Jan-2024</small>
</a>
</li>
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-4.0.56.Final.tar.gz">
<i class="fa fa-cloud-download"></i>
4.0.56.Final
<small>&dash; 05-Feb-2018</small>
</a>
</li>
<li>
<a href="https://github.com/netty/netty/archive/refs/tags/netty-3.10.6.Final.tar.gz">
<i class="fa fa-cloud-download"></i>
3.10.6.Final
<small>&dash; 29-Jun-2016</small>
</a>
</li>
<li>
<a href="https://www.tldrlegal.com/l/APACHE2">
<i class="fa fa-gavel"></i>
Apache License 2.0
</a>
</li>
<li>
<a href="https://github.com/netty/netty/releases">
<i class="fa fa-archive"></i>
Previous Releases
</a>
</li>
<li>
<a href="https://oss.sonatype.org/content/repositories/snapshots/io/netty/">
<i class="fa fa-flask"></i>
Nightly Builds
</a>
</li>
</ul>
</li>
<li class="dropdown">
<a href="../wiki/index.html">
Documentation
</a>
<ul class="dropdown-menu">
<li>
<a href="../wiki/user-guide.html">
<i class="fa fa-book"></i>
User guide
</a>
</li>
<li>
<a href="../5.0/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 5.0
</a>
</li>
<li>
<a href="../4.1/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 4.1
</a>
</li>
<li>
<a href="../4.0/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 4.0
</a>
</li>
<li>
<a href="../3.10/api/index.html">
<i class="fa fa-file-text"></i>
Javadoc - 3.10
</a>
</li>
<li>
<a href="../wiki/all-documents.html">
<i class="fa fa-list"></i>
All Documents
</a>
</li>
<li>
<a href="../wiki/related-articles.html">
<i class="fa fa-bookmark"></i>
Related Articles
</a>
</li>
<li class="hidden-xs" id="bookpromo-dropdown">
<a href="https://www.manning.com/maurer/">
<img src="../images/netty-in-action.gif">
<br>
<small>
Use code <strong>mlnettyco</strong>
<br>
for a 37% discount!
</small>
</a>
</li>
</ul>
</li>
<li class="dropdown">
<a href="../community.html">
Get Involved
</a>
<ul class="dropdown-menu">
<li>
<a href="https://github.com/netty/netty">
<i class="fa fa-github-square"></i>
Github
</a>
</li>
<li>
<a href="https://stackoverflow.com/questions/tagged/netty">
<i class="fa fa-stack-overflow"></i>
StackOverflow
</a>
</li>
<li>
<a href="https://twitter.com/netty_project">
<i class="fa fa-twitter-square"></i>
@netty_project
</a>
</li>
<li>
<a href="../wiki/developer-guide.html">
<i class="fa fa-cogs"></i>
Developer Guide
</a>
</li>
<li>
<a href="https://discord.gg/GkGzzdQM5d">
<i class="fa fa-comment"></i>
Discord Server
</a>
</li>
<li>
<a href="../sponsor/thanks.html">
<i class="fa fa-usd"></i>
Sponsors
</a>
</li>
<li>
<a href="../wiki/adopters.html">
<i class="fa fa-users"></i>
Adopters
</a>
</li>
<li>
<a href="../wiki/related-projects.html">
<i class="fa fa-chain"></i>
Related Projects
</a>
</li>
</ul>
</li>
<li class="visible-xs" id="bookpromo-nav">
<a href="https://www.manning.com/maurer/">
<img src="../images/netty-in-action.gif">
<br>
<small>
Use code <strong>mlnettyco</strong>
<br>
for a 37% discount!
</small>
</a>
</li>
<li>
<a href="https://feeds.feedburner.com/netty_project">
<i class="fa fa-rss"></i>
</a>
</li>
</ul>
<form action="../search.html" class="navbar-form navbar-right hidden-sm" method="GET" onsubmit="return validateGlobalSearchQuery()" role="search">
<div class="form-group">
<input class="search-query form-control" id="global-search-query" name="q" placeholder="Search" type="text">
</div>
</form>
</div>
</div>
</nav>
<div id="content">
<div class="container">
<div class="wiki-item">
<h1>User guide for 5.x</h1>
<div class="alert alert-info">
Did you know this page is automatically generated from
<a href="https://github.com/netty/netty/wiki/User-guide-for-5.x">a Github Wiki page?</a>
You can improve it by yourself
<a href="https://github.com/netty/netty/wiki/User-guide-for-5.x">here!</a>
</div>
<div class="row">
<div class="col-md-9">
<div id="wiki-body" class="gollum-markdown-content">
              <div class="markdown-body">
                <h3 id="wiki-h3-0">
<a id="user-content-3rd-party-translations" class="anchor" aria-hidden="true" tabindex="-1" href="#3rd-party-translations"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3rd-party translations</h3>
<ul>
<li><a href="http://ifeve.com/netty5-user-guide/" rel="nofollow">Simplified Chinese</a></li>
</ul>
<h2 id="wiki-h2-1">
<a id="user-content-preface" class="anchor" aria-hidden="true" tabindex="-1" href="#preface"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Preface</h2>
<h3 id="wiki-h3-2">
<a id="user-content-the-problem" class="anchor" aria-hidden="true" tabindex="-1" href="#the-problem"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The Problem</h3>
<p>Nowadays we use general purpose applications or libraries to communicate with each other. For example, we often use an HTTP client library to retrieve information from a web server and to invoke a remote procedure call via web services.</p>
<p>However, a general purpose protocol or its implementation sometimes does not scale very well. It is like we don't use a general purpose HTTP server to exchange huge files, e-mail messages, and near-realtime messages such as financial information and multiplayer game data. What's required is a highly optimized protocol implementation which is dedicated to a special purpose. For example, you might want to implement an HTTP server which is optimized for AJAX-based chat application, media streaming, or large file transfer. You could even want to design and implement a whole new protocol which is precisely tailored to your need.</p>
<p>Another inevitable case is when you have to deal with a legacy proprietary protocol to ensure the interoperability with an old system. What matters in this case is how quickly we can implement that protocol while not sacrificing the stability and performance of the resulting application.</p>
<h2 id="wiki-h2-3">
<a id="user-content-the-solution" class="anchor" aria-hidden="true" tabindex="-1" href="#the-solution"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The Solution</h2>
<p><em><a href="http://netty.io/" rel="nofollow">The Netty project</a></em> is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance Â· high-scalability protocol servers and clients.</p>
<p>In other words, Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server development.</p>
<p>'Quick and easy' does not mean that a resulting application will suffer from a maintainability or a performance issue. Netty has been designed carefully with the experiences earned from the implementation of a lot of protocols such as FTP, SMTP, HTTP, and various binary and text-based legacy protocols. As a result, Netty has succeeded to find a way to achieve ease of development, performance, stability, and flexibility without a compromise.</p>
<p>Some users might already have found other network application framework that claims to have the same advantage, and you might want to ask what makes Netty so different from them. The answer is the philosophy where it is built on. Netty is designed to give you the most comfortable experience both in terms of the API and the implementation from the day one. It is not something tangible but you will realize that this philosophy will make your life much easier as you read this guide and play with Netty.</p>
<h2 id="wiki-h2-4">
<a id="user-content-getting-started" class="anchor" aria-hidden="true" tabindex="-1" href="#getting-started"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting Started</h2>
<p>This chapter tours around the core constructs of Netty with simple examples to let you get started quickly. You will be able to write a client and a server on top of Netty right away when you are at the end of this chapter.</p>
<p>If you prefer top-down approach in learning something, you might want to start from Chapter 2, Architectural Overview and get back here.</p>
<h3 id="wiki-h3-5">
<a id="user-content-before-getting-started" class="anchor" aria-hidden="true" tabindex="-1" href="#before-getting-started"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Before Getting Started</h3>
<p>The minimum requirements to run the examples which are introduced in this chapter are only two; the latest version of Netty and JDK 1.6 or above. The latest version of Netty is available in <a href="http://netty.io/downloads.html" rel="nofollow">the project download page</a>. To download the right version of JDK, please refer to your preferred JDK vendor's web site.</p>
<p>As you read, you might have more questions about the classes introduced in this chapter. Please refer to the API reference whenever you want to know more about them. All class names in this document are linked to the online API reference for your convenience. Also, please don't hesitate to <a href="http://netty.io/community.html" rel="nofollow">contact the Netty project community</a> and let us know if there's any incorrect information, errors in grammar and typo, and if you have a good idea to improve the documentation.</p>
<h3 id="wiki-h3-6">
<a id="user-content-writing-a-discard-server" class="anchor" aria-hidden="true" tabindex="-1" href="#writing-a-discard-server"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Writing a Discard Server</h3>
<p>The most simplistic protocol in the world is not 'Hello, World!' but <a href="http://tools.ietf.org/html/rfc863" rel="nofollow"><code>DISCARD</code></a>. It's a protocol which discards any received data without any response.</p>
<p>To implement the <code>DISCARD</code> protocol, the only thing you need to do is to ignore all received data. Let us start straight from the handler implementation, which handles I/O events generated by Netty.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.discard;

import io.netty.buffer.ByteBuf;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelHandlerAdapter;

/**
 * Handles a server-side channel.
 */
public class DiscardServerHandler extends ChannelHandlerAdapter { // (1)

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) { // (2)
        // Discard the received data silently.
        ((ByteBuf) msg).release(); // (3)
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // (4)
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">discard</span>;&#x000A;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">buffer</span>.<span class="pl-s1">ByteBuf</span>;&#x000A;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">ChannelHandlerContext</span>;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">ChannelHandlerAdapter</span>;&#x000A;&#x000A;<span class="pl-c">/**</span>&#x000A;<span class="pl-c"> * Handles a server-side channel.</span>&#x000A;<span class="pl-c"> */</span>&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DiscardServerHandler</span> <span class="pl-k">extends</span> <span class="pl-smi">ChannelHandlerAdapter</span> { <span class="pl-c">// (1)</span>&#x000A;&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) { <span class="pl-c">// (2)</span>&#x000A;        <span class="pl-c">// Discard the received data silently.</span>&#x000A;        ((<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>).<span class="pl-en">release</span>(); <span class="pl-c">// (3)</span>&#x000A;    }&#x000A;&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">exceptionCaught</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Throwable</span> <span class="pl-s1">cause</span>) { <span class="pl-c">// (4)</span>&#x000A;        <span class="pl-c">// Close the connection when an exception is raised.</span>&#x000A;        <span class="pl-s1">cause</span>.<span class="pl-en">printStackTrace</span>();&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>
<code>DiscardServerHandler</code> extends <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" rel="nofollow"><code>ChannelHandlerAdapter</code></a>, which is an implementation of <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a>. <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> provides various event handler methods that you can override. For now, it is just enough to extend <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" rel="nofollow"><code>ChannelHandlerAdapter</code></a> rather than to implement the handler interface by yourself.</li>
<li>We override the <code>channelRead()</code> event handler method here. This method is called with the received message, whenever new data is received from a client.  In this example, the type of the received message is <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a>.</li>
<li>To implement the <code>DISCARD</code> protocol, the handler has to ignore the received message.  <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a> is a reference-counted object which has to be released explicitly via the <code>release()</code> method.  Please keep in mind that it is the handler's responsibility to release any reference-counted object passed to the handler.  Usually, <code>channelRead()</code> handler method is implemented like the following:</li>
</ol>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    try {
        // Do something with msg
    } finally {
        ReferenceCountUtil.release(msg);
    }
}"><pre><span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;    <span class="pl-k">try</span> {&#x000A;        <span class="pl-c">// Do something with msg</span>&#x000A;    } <span class="pl-k">finally</span> {&#x000A;        <span class="pl-smi">ReferenceCountUtil</span>.<span class="pl-en">release</span>(<span class="pl-s1">msg</span>);&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>The <code>exceptionCaught()</code> event handler method is called with a <code>Throwable</code> when an exception was raised by Netty due to an I/O error or by a handler implementation due to the exception thrown while processing events. In most cases, the caught exception should be logged and its associated channel should be closed here, although the implementation of this method can be different depending on what you want to do to deal with an exceptional situation. For example, you might want to send a response message with an error code before closing the connection.</li>
</ol>
<p>So far so good. We have implemented the first half of the <code>DISCARD</code> server. What's left now is to write the <code>main()</code> method which starts the server with the <code>DiscardServerHandler</code>.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.discard;
    
import io.netty.bootstrap.ServerBootstrap;

import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
    
/**
 * Discards any incoming data.
 */
public class DiscardServer {
    
    private int port;
    
    public DiscardServer(int port) {
        this.port = port;
    }
    
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1)
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap(); // (2)
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class) // (3)
             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { // (4)
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ch.pipeline().addLast(new DiscardServerHandler());
                 }
             })
             .option(ChannelOption.SO_BACKLOG, 128)          // (5)
             .childOption(ChannelOption.SO_KEEPALIVE, true); // (6)
    
            // Bind and start to accept incoming connections.
            ChannelFuture f = b.bind(port).sync(); // (7)
    
            // Wait until the server socket is closed.
            // In this example, this does not happen, but you can do that to gracefully
            // shut down your server.
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
    
    public static void main(String[] args) throws Exception {
        int port;
        if (args.length &gt; 0) {
            port = Integer.parseInt(args[0]);
        } else {
            port = 8080;
        }
        new DiscardServer(port).run();
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">discard</span>;&#x000A;    &#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">bootstrap</span>.<span class="pl-s1">ServerBootstrap</span>;&#x000A;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">ChannelFuture</span>;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">ChannelInitializer</span>;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">ChannelOption</span>;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">EventLoopGroup</span>;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">nio</span>.<span class="pl-s1">NioEventLoopGroup</span>;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">socket</span>.<span class="pl-s1">SocketChannel</span>;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">channel</span>.<span class="pl-s1">socket</span>.<span class="pl-s1">nio</span>.<span class="pl-s1">NioServerSocketChannel</span>;&#x000A;    &#x000A;<span class="pl-c">/**</span>&#x000A;<span class="pl-c"> * Discards any incoming data.</span>&#x000A;<span class="pl-c"> */</span>&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DiscardServer</span> {&#x000A;    &#x000A;    <span class="pl-k">private</span> <span class="pl-smi">int</span> <span class="pl-s1">port</span>;&#x000A;    &#x000A;    <span class="pl-k">public</span> <span class="pl-smi">DiscardServer</span>(<span class="pl-smi">int</span> <span class="pl-s1">port</span>) {&#x000A;        <span class="pl-smi">this</span>.<span class="pl-s1">port</span> = <span class="pl-s1">port</span>;&#x000A;    }&#x000A;    &#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">run</span>() <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {&#x000A;        <span class="pl-smi">EventLoopGroup</span> <span class="pl-s1">bossGroup</span> = <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>(); <span class="pl-c">// (1)</span>&#x000A;        <span class="pl-smi">EventLoopGroup</span> <span class="pl-s1">workerGroup</span> = <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>();&#x000A;        <span class="pl-k">try</span> {&#x000A;            <span class="pl-smi">ServerBootstrap</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">ServerBootstrap</span>(); <span class="pl-c">// (2)</span>&#x000A;            <span class="pl-s1">b</span>.<span class="pl-en">group</span>(<span class="pl-s1">bossGroup</span>, <span class="pl-s1">workerGroup</span>)&#x000A;             .<span class="pl-en">channel</span>(<span class="pl-smi">NioServerSocketChannel</span>.<span class="pl-k">class</span>) <span class="pl-c">// (3)</span>&#x000A;             .<span class="pl-en">childHandler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() { <span class="pl-c">// (4)</span>&#x000A;                 <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;                 <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {&#x000A;                     <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">DiscardServerHandler</span>());&#x000A;                 }&#x000A;             })&#x000A;             .<span class="pl-en">option</span>(<span class="pl-smi">ChannelOption</span>.<span class="pl-c1">SO_BACKLOG</span>, <span class="pl-c1">128</span>)          <span class="pl-c">// (5)</span>&#x000A;             .<span class="pl-en">childOption</span>(<span class="pl-smi">ChannelOption</span>.<span class="pl-c1">SO_KEEPALIVE</span>, <span class="pl-c1">true</span>); <span class="pl-c">// (6)</span>&#x000A;    &#x000A;            <span class="pl-c">// Bind and start to accept incoming connections.</span>&#x000A;            <span class="pl-smi">ChannelFuture</span> <span class="pl-s1">f</span> = <span class="pl-s1">b</span>.<span class="pl-en">bind</span>(<span class="pl-s1">port</span>).<span class="pl-en">sync</span>(); <span class="pl-c">// (7)</span>&#x000A;    &#x000A;            <span class="pl-c">// Wait until the server socket is closed.</span>&#x000A;            <span class="pl-c">// In this example, this does not happen, but you can do that to gracefully</span>&#x000A;            <span class="pl-c">// shut down your server.</span>&#x000A;            <span class="pl-s1">f</span>.<span class="pl-en">channel</span>().<span class="pl-en">closeFuture</span>().<span class="pl-en">sync</span>();&#x000A;        } <span class="pl-k">finally</span> {&#x000A;            <span class="pl-s1">workerGroup</span>.<span class="pl-en">shutdownGracefully</span>();&#x000A;            <span class="pl-s1">bossGroup</span>.<span class="pl-en">shutdownGracefully</span>();&#x000A;        }&#x000A;    }&#x000A;    &#x000A;    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {&#x000A;        <span class="pl-smi">int</span> <span class="pl-s1">port</span>;&#x000A;        <span class="pl-k">if</span> (<span class="pl-s1">args</span>.<span class="pl-s1">length</span> &gt; <span class="pl-c1">0</span>) {&#x000A;            <span class="pl-s1">port</span> = <span class="pl-smi">Integer</span>.<span class="pl-en">parseInt</span>(<span class="pl-s1">args</span>[<span class="pl-c1">0</span>]);&#x000A;        } <span class="pl-k">else</span> {&#x000A;            <span class="pl-s1">port</span> = <span class="pl-c1">8080</span>;&#x000A;        }&#x000A;        <span class="pl-k">new</span> <span class="pl-smi">DiscardServer</span>(<span class="pl-s1">port</span>).<span class="pl-en">run</span>();&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>
<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" rel="nofollow"><code>NioEventLoopGroup</code></a> is a multithreaded event loop that handles I/O operation.  Netty provides various <a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" rel="nofollow"><code>EventLoopGroup</code></a> implementations for different kind of transports. We are implementing a server-side application in this example, and therefore two <a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" rel="nofollow"><code>NioEventLoopGroup</code></a> will be used. The first one, often called 'boss', accepts an incoming connection. The second one, often called 'worker', handles the traffic of the accepted connection once the boss accepts the connection and registers the accepted connection to the worker.  How many Threads are used and how they are mapped to the created <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a>s depends on the <a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" rel="nofollow"><code>EventLoopGroup</code></a> implementation and may be even configurable via a constructor.</li>
<li>
<a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" rel="nofollow"><code>ServerBootstrap</code></a> is a helper class that sets up a server. You can set up the server using a <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a> directly. However, please note that this is a tedious process, and you do not need to do that in most cases.</li>
<li>Here, we specify to use the <a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" rel="nofollow"><code>NioServerSocketChannel</code></a> class which is used to instantiate a new <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a> to accept incoming connections.</li>
<li>The handler specified here will always be evaluated by a newly accepted <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a>. The <a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" rel="nofollow"><code>ChannelInitializer</code></a> is a special handler that is purposed to help a user configure a new <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a>.  It is most likely that you want to configure the <a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" rel="nofollow"><code>ChannelPipeline</code></a> of the new <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a> by adding some handlers such as <code>DiscardServerHandler</code> to implement your network application.  As the application gets complicated, it is likely that you will add more handlers to the pipeline and extract this anonymous class into a top level class eventually.</li>
<li>You can also set the parameters which are specific to the <code>Channel</code> implementation. We are writing a TCP/IP server, so we are allowed to set the socket options such as <code>tcpNoDelay</code> and <code>keepAlive</code>. Please refer to the apidocs of <a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" rel="nofollow"><code>ChannelOption</code></a> and the specific <a href="http://netty.io/5.0/api/io/netty/channel/ChannelConfig.html" rel="nofollow"><code>ChannelConfig</code></a> implementations to get an overview about the supported <code>ChannelOption</code>s.</li>
<li>Did you notice <code>option()</code> and <code>childOption()</code>?  <code>option()</code> is for the <a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" rel="nofollow"><code>NioServerSocketChannel</code></a> that accepts incoming connections. <code>childOption()</code> is for the <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a>s accepted by the parent <a href="http://netty.io/5.0/api/io/netty/channel/ServerChannel.html" rel="nofollow"><code>ServerChannel</code></a>, which is <a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" rel="nofollow"><code>NioServerSocketChannel</code></a> in this case.</li>
<li>We are ready to go now. What's left is to bind to the port and to start the server. Here, we bind to the port <code>8080</code> of all NICs (network interface cards) in the machine. You can now call the <code>bind()</code> method as many times as you want (with different bind addresses.)</li>
</ol>
<p>Congratulations! You've just finished your first server on top of Netty.</p>
<h3 id="wiki-h3-7">
<a id="user-content-looking-into-the-received-data" class="anchor" aria-hidden="true" tabindex="-1" href="#looking-into-the-received-data"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Looking into the Received Data</h3>
<p>Now that we have written our first server, we need to test if it really works. The easiest way to test it is to use the <em>telnet</em> command. For example, you could enter <code>telnet localhost 8080</code> in the command line and type something.</p>
<p>However, can we say that the server is working fine? We cannot really know that because it is a discard server. You will not get any response at all. To prove it is really working, let us modify the server to print what it has received.</p>
<p>We already know that <code>channelRead()</code> method is invoked whenever data is received. Let us put some code into the <code>channelRead()</code> method of the <code>DiscardServerHandler</code>:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf in = (ByteBuf) msg;
    try {
        while (in.isReadable()) { // (1)
            System.out.print((char) in.readByte());
            System.out.flush();
        }
    } finally {
        ReferenceCountUtil.release(msg); // (2)
    }
}"><pre><span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;    <span class="pl-smi">ByteBuf</span> <span class="pl-s1">in</span> = (<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>;&#x000A;    <span class="pl-k">try</span> {&#x000A;        <span class="pl-k">while</span> (<span class="pl-s1">in</span>.<span class="pl-en">isReadable</span>()) { <span class="pl-c">// (1)</span>&#x000A;            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">print</span>((<span class="pl-smi">char</span>) <span class="pl-s1">in</span>.<span class="pl-en">readByte</span>());&#x000A;            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">flush</span>();&#x000A;        }&#x000A;    } <span class="pl-k">finally</span> {&#x000A;        <span class="pl-smi">ReferenceCountUtil</span>.<span class="pl-en">release</span>(<span class="pl-s1">msg</span>); <span class="pl-c">// (2)</span>&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>This inefficient loop can actually be simplified to: <code>System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII))</code>
</li>
<li>Alternatively, you could do <code>in.release()</code> here.</li>
</ol>
<p>If you run the <em>telnet</em> command again, you will see the server prints what has received.</p>
<p>The full source code of the discard server is located in the <a href="http://netty.io/5.0/xref/io/netty/example/discard/package-summary.html" rel="nofollow"><code>io.netty.example.discard</code></a> package of the distribution.</p>
<h3 id="wiki-h3-8">
<a id="user-content-writing-an-echo-server" class="anchor" aria-hidden="true" tabindex="-1" href="#writing-an-echo-server"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Writing an Echo Server</h3>
<p>So far, we have been consuming data without responding at all. A server, however, is usually supposed to respond to a request. Let us learn how to write a response message to a client by implementing the <a href="http://tools.ietf.org/html/rfc862" rel="nofollow"><code>ECHO</code></a> protocol, where any received data is sent back.</p>
<p>The only difference from the discard server we have implemented in the previous sections is that it sends the received data back instead of printing the received data out to the console. Therefore, it is enough again to modify the <code>channelRead()</code> method:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.write(msg); // (1)
        ctx.flush(); // (2)
    }"><pre>    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">write</span>(<span class="pl-s1">msg</span>); <span class="pl-c">// (1)</span>&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">flush</span>(); <span class="pl-c">// (2)</span>&#x000A;    }</pre></div>
<ol>
<li>A <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html" rel="nofollow"><code>ChannelHandlerContext</code></a> object provides various operations that enable you to trigger various I/O events and operations.  Here, we invoke <code>write(Object)</code> to write the received message in verbatim.  Please note that we did not release the received message unlike we did in the <code>DISCARD</code> example.  It is because Netty releases it for you when it is written out to the wire.</li>
<li>
<code>ctx.write(Object)</code> does not make the message written out to the wire.  It is buffered internally, and then flushed out to the wire by <code>ctx.flush()</code>.  Alternatively, you could call <code>ctx.writeAndFlush(msg)</code> for brevity.</li>
</ol>
<p>If you run the <em>telnet</em> command again, you will see the server sends back whatever you have sent to it.</p>
<p>The full source code of the echo server is located in the <a href="http://netty.io/5.0/xref/io/netty/example/echo/package-summary.html" rel="nofollow"><code>io.netty.example.echo</code></a> package of the distribution.</p>
<h3 id="wiki-h3-9">
<a id="user-content-writing-a-time-server" class="anchor" aria-hidden="true" tabindex="-1" href="#writing-a-time-server"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Writing a Time Server</h3>
<p>The protocol to implement in this section is the <a href="http://tools.ietf.org/html/rfc868" rel="nofollow"><code>TIME</code></a> protocol. It is different from the previous examples in that it sends a message, which contains a 32-bit integer, without receiving any requests and closes the connection once the message is sent. In this example, you will learn how to construct and send a message, and to close the connection on completion.</p>
<p>Because we are going to ignore any received data but to send a message as soon as a connection is established, we cannot use the <code>channelRead()</code> method this time. Instead, we should override the <code>channelActive()</code> method. The following is the implementation:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.time;

public class TimeServerHandler extends ChannelHandlerAdapter {

    @Override
    public void channelActive(final ChannelHandlerContext ctx) { // (1)
        final ByteBuf time = ctx.alloc().buffer(4); // (2)
        time.writeInt((int) (System.currentTimeMillis() / 1000L + 2208988800L));
        
        final ChannelFuture f = ctx.writeAndFlush(time); // (3)
        f.addListener(new ChannelFutureListener() {

            @Override
            public void operationComplete(ChannelFuture future) {
                assert f == future;
                ctx.close();
            }
        }); // (4)
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">time</span>;&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeServerHandler</span> <span class="pl-k">extends</span> <span class="pl-smi">ChannelHandlerAdapter</span> {&#x000A;&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelActive</span>(<span class="pl-k">final</span> <span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>) { <span class="pl-c">// (1)</span>&#x000A;        <span class="pl-k">final</span> <span class="pl-smi">ByteBuf</span> <span class="pl-s1">time</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">buffer</span>(<span class="pl-c1">4</span>); <span class="pl-c">// (2)</span>&#x000A;        <span class="pl-s1">time</span>.<span class="pl-en">writeInt</span>((<span class="pl-smi">int</span>) (<span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>() / <span class="pl-c1">1000L</span> + <span class="pl-c1">2208988800L</span>));&#x000A;        &#x000A;        <span class="pl-k">final</span> <span class="pl-smi">ChannelFuture</span> <span class="pl-s1">f</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">writeAndFlush</span>(<span class="pl-s1">time</span>); <span class="pl-c">// (3)</span>&#x000A;        <span class="pl-s1">f</span>.<span class="pl-en">addListener</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelFutureListener</span>() {&#x000A;&#x000A;            <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;            <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">operationComplete</span>(<span class="pl-smi">ChannelFuture</span> <span class="pl-s1">future</span>) {&#x000A;                <span class="pl-k">assert</span> <span class="pl-s1">f</span> == <span class="pl-s1">future</span>;&#x000A;                <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;            }&#x000A;        }); <span class="pl-c">// (4)</span>&#x000A;    }&#x000A;    &#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">exceptionCaught</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Throwable</span> <span class="pl-s1">cause</span>) {&#x000A;        <span class="pl-s1">cause</span>.<span class="pl-en">printStackTrace</span>();&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>
<p>As explained, the <code>channelActive()</code> method will be invoked when a connection is established and ready to generate traffic.  Let's write a 32-bit integer that represents the current time in this method.</p>
</li>
<li>
<p>To send a new message, we need to allocate a new buffer which will contain the message. We are going to write a 32-bit integer, and therefore we need a <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a> whose capacity is at least 4 bytes. Get the current <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBufAllocator.html" rel="nofollow"><code>ByteBufAllocator</code></a> via <code>ChannelHandlerContext.alloc()</code> and allocate a new buffer.</p>
</li>
<li>
<p>As usual, we write the constructed message.</p>
<p>But wait, where's the flip? Didn't we used to call <code>java.nio.ByteBuffer.flip()</code> before sending a message in NIO? <code>ByteBuf</code> does not have such a method because it has two pointers; one for read operations and the other for write operations. The writer index increases when you write something to a <code>ByteBuf</code> while the reader index does not change. The reader index and the writer index represents where the message starts and ends respectively.</p>
<p>In contrast, NIO buffer does not provide a clean way to figure out where the message content starts and ends without calling the flip method. You will be in trouble when you forget to flip the buffer because nothing or incorrect data will be sent. Such an error does not happen in Netty because we have different pointer for different operation types. You will find it makes your life much easier as you get used to it -- a life without flipping out!</p>
<p>Another point to note is that the <code>ChannelHandlerContext.write()</code> (and <code>writeAndFlush()</code>) method returns a <a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" rel="nofollow"><code>ChannelFuture</code></a>. A <a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" rel="nofollow"><code>ChannelFuture</code></a> represents an I/O operation which has not yet occurred. It means, any requested operation might not have been performed yet because all operations are asynchronous in Netty. For example, the following code might close the connection even before a message is sent:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Channel ch = ...;
ch.writeAndFlush(message);
ch.close();"><pre><span class="pl-smi">Channel</span> <span class="pl-s1">ch</span> = ...;&#x000A;<span class="pl-s1">ch</span>.<span class="pl-en">writeAndFlush</span>(<span class="pl-s1">message</span>);&#x000A;<span class="pl-s1">ch</span>.<span class="pl-en">close</span>();</pre></div>
<p>Therefore, you need to call the <code>close()</code> method after the <a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" rel="nofollow"><code>ChannelFuture</code></a> is complete, which was returned by the <code>write()</code> method, and it notifies its listeners when the write operation has been done. Please note that, <code>close()</code> also might not close the connection immediately, and it returns a <a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" rel="nofollow"><code>ChannelFuture</code></a>.</p>
</li>
<li>
<p>How do we get notified when a write request is finished then? This is as simple as adding a <a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" rel="nofollow"><code>ChannelFutureListener</code></a> to the returned <code>ChannelFuture</code>. Here, we created a new anonymous <a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" rel="nofollow"><code>ChannelFutureListener</code></a> which closes the <code>Channel</code> when the operation is done.</p>
<p>Alternatively, you could simplify the code using a pre-defined listener:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="f.addListener(ChannelFutureListener.CLOSE);"><pre><span class="pl-s1">f</span>.<span class="pl-en">addListener</span>(<span class="pl-smi">ChannelFutureListener</span>.<span class="pl-c1">CLOSE</span>);</pre></div>
</li>
</ol>
<p>To test if our time server works as expected, you can use the UNIX <code>rdate</code> command:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ rdate -o &lt;port&gt; -p &lt;host&gt;"><pre class="notranslate"><code>$ rdate -o &lt;port&gt; -p &lt;host&gt;&#x000A;</code></pre></div>
<p>where <code>&lt;port&gt;</code> is the port number you specified in the <code>main()</code> method and <code>&lt;host&gt;</code> is usually <code>localhost</code>.</p>
<h3 id="wiki-h3-10">
<a id="user-content-writing-a-time-client" class="anchor" aria-hidden="true" tabindex="-1" href="#writing-a-time-client"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Writing a Time Client</h3>
<p>Unlike <code>DISCARD</code> and <code>ECHO</code> servers, we need a client for the <code>TIME</code> protocol because a human cannot translate a 32-bit binary data into a date on a calendar. In this section, we discuss how to make sure the server works correctly and learn how to write a client with Netty.</p>
<p>The biggest and only difference between a server and a client in Netty is that different <a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" rel="nofollow"><code>Bootstrap</code></a> and <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a> implementations are used. Please take a look at the following code:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.time;

public class TimeClient {
    public static void main(String[] args) throws Exception {
        String host = args[0];
        int port = Integer.parseInt(args[1]);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            Bootstrap b = new Bootstrap(); // (1)
            b.group(workerGroup); // (2)
            b.channel(NioSocketChannel.class); // (3)
            b.option(ChannelOption.SO_KEEPALIVE, true); // (4)
            b.handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                @Override
                public void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(new TimeClientHandler());
                }
            });
            
            // Start the client.
            ChannelFuture f = b.connect(host, port).sync(); // (5)

            // Wait until the connection is closed.
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
        }
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">time</span>;&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeClient</span> {&#x000A;    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {&#x000A;        <span class="pl-smi">String</span> <span class="pl-s1">host</span> = <span class="pl-s1">args</span>[<span class="pl-c1">0</span>];&#x000A;        <span class="pl-smi">int</span> <span class="pl-s1">port</span> = <span class="pl-smi">Integer</span>.<span class="pl-en">parseInt</span>(<span class="pl-s1">args</span>[<span class="pl-c1">1</span>]);&#x000A;        <span class="pl-smi">EventLoopGroup</span> <span class="pl-s1">workerGroup</span> = <span class="pl-k">new</span> <span class="pl-smi">NioEventLoopGroup</span>();&#x000A;        &#x000A;        <span class="pl-k">try</span> {&#x000A;            <span class="pl-smi">Bootstrap</span> <span class="pl-s1">b</span> = <span class="pl-k">new</span> <span class="pl-smi">Bootstrap</span>(); <span class="pl-c">// (1)</span>&#x000A;            <span class="pl-s1">b</span>.<span class="pl-en">group</span>(<span class="pl-s1">workerGroup</span>); <span class="pl-c">// (2)</span>&#x000A;            <span class="pl-s1">b</span>.<span class="pl-en">channel</span>(<span class="pl-smi">NioSocketChannel</span>.<span class="pl-k">class</span>); <span class="pl-c">// (3)</span>&#x000A;            <span class="pl-s1">b</span>.<span class="pl-en">option</span>(<span class="pl-smi">ChannelOption</span>.<span class="pl-c1">SO_KEEPALIVE</span>, <span class="pl-c1">true</span>); <span class="pl-c">// (4)</span>&#x000A;            <span class="pl-s1">b</span>.<span class="pl-en">handler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {&#x000A;                <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;                <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {&#x000A;                    <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">TimeClientHandler</span>());&#x000A;                }&#x000A;            });&#x000A;            &#x000A;            <span class="pl-c">// Start the client.</span>&#x000A;            <span class="pl-smi">ChannelFuture</span> <span class="pl-s1">f</span> = <span class="pl-s1">b</span>.<span class="pl-en">connect</span>(<span class="pl-s1">host</span>, <span class="pl-s1">port</span>).<span class="pl-en">sync</span>(); <span class="pl-c">// (5)</span>&#x000A;&#x000A;            <span class="pl-c">// Wait until the connection is closed.</span>&#x000A;            <span class="pl-s1">f</span>.<span class="pl-en">channel</span>().<span class="pl-en">closeFuture</span>().<span class="pl-en">sync</span>();&#x000A;        } <span class="pl-k">finally</span> {&#x000A;            <span class="pl-s1">workerGroup</span>.<span class="pl-en">shutdownGracefully</span>();&#x000A;        }&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>
<a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" rel="nofollow"><code>Bootstrap</code></a> is similar to <a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" rel="nofollow"><code>ServerBootstrap</code></a> except that it's for non-server channels such as a client-side or connectionless channel.</li>
<li>If you specify only one <a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" rel="nofollow"><code>EventLoopGroup</code></a>, it will be used both as a boss group and as a worker group. The boss worker is not used for the client side though.</li>
<li>Instead of <a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" rel="nofollow"><code>NioServerSocketChannel</code></a>, <a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html" rel="nofollow"><code>NioSocketChannel</code></a> is being used to create a client-side <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a>.</li>
<li>Note that we do not use <code>childOption()</code> here unlike we did with <code>ServerBootstrap</code> because the client-side <a href="http://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html" rel="nofollow"><code>SocketChannel</code></a> does not have a parent.</li>
<li>We should call the <code>connect()</code> method instead of the <code>bind()</code> method.</li>
</ol>
<p>As you can see, it is not really different from the the server-side code. What about the <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> implementation? It should receive a 32-bit integer from the server, translate it into a human readable format, print the translated time, and close the connection:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.time;

import java.util.Date;

public class TimeClientHandler extends ChannelHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf m = (ByteBuf) msg; // (1)
        try {
            long currentTimeMillis = (m.readUnsignedInt() - 2208988800L) * 1000L;
            System.out.println(new Date(currentTimeMillis));
            ctx.close();
        } finally {
            m.release();
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">time</span>;&#x000A;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">Date</span>;&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeClientHandler</span> <span class="pl-k">extends</span> <span class="pl-smi">ChannelHandlerAdapter</span> {&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;        <span class="pl-smi">ByteBuf</span> <span class="pl-s1">m</span> = (<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>; <span class="pl-c">// (1)</span>&#x000A;        <span class="pl-k">try</span> {&#x000A;            <span class="pl-smi">long</span> <span class="pl-s1">currentTimeMillis</span> = (<span class="pl-s1">m</span>.<span class="pl-en">readUnsignedInt</span>() - <span class="pl-c1">2208988800L</span>) * <span class="pl-c1">1000L</span>;&#x000A;            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-k">new</span> <span class="pl-smi">Date</span>(<span class="pl-s1">currentTimeMillis</span>));&#x000A;            <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;        } <span class="pl-k">finally</span> {&#x000A;            <span class="pl-s1">m</span>.<span class="pl-en">release</span>();&#x000A;        }&#x000A;    }&#x000A;&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">exceptionCaught</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Throwable</span> <span class="pl-s1">cause</span>) {&#x000A;        <span class="pl-s1">cause</span>.<span class="pl-en">printStackTrace</span>();&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>In TCP/IP, Netty reads the data sent from a peer into a [<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a>].</li>
</ol>
<p>It looks very simple and does not look any different from the server side example. However, this handler sometimes will refuse to work raising an <code>IndexOutOfBoundsException</code>. We discuss why this happens in the next section.</p>
<h3 id="wiki-h3-11">
<a id="user-content-dealing-with-a-stream-based-transport" class="anchor" aria-hidden="true" tabindex="-1" href="#dealing-with-a-stream-based-transport"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Dealing with a Stream-based Transport</h3>
<h4 id="wiki-h4-12">
<a id="user-content-one-small-caveat-of-socket-buffer" class="anchor" aria-hidden="true" tabindex="-1" href="#one-small-caveat-of-socket-buffer"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>One Small Caveat of Socket Buffer</h4>
<p>In a stream-based transport such as TCP/IP, received data is stored into a socket receive buffer. Unfortunately, the buffer of a stream-based transport is not a queue of packets but a queue of bytes. It means, even if you sent two messages as two independent packets, an operating system will not treat them as two messages but as just a bunch of bytes. Therefore, there is no guarantee that what you read is exactly what your remote peer wrote. For example, let us assume that the TCP/IP stack of an operating system has received three packets:</p>
<p><img src="https://camo.githubusercontent.com/6b97e1b759a9389fedfe81112d8bf802f97ffc02e07e5c088f9b069bb2744e21/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262" alt="Three packets received as they were sent" data-canonical-src="http://uml.mvnsearch.org/gist/82e3fbe0e2d4df28322b"></p>
<p>Because of this general property of a stream-based protocol, there's high chance of reading them in the following fragmented form in your application:</p>
<p><img src="https://camo.githubusercontent.com/759375978c42439bca1a889e58e087a19d39cd4bfaac5c55cf8f16977e648774/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f6233316330626437626266633639666438326436" alt="Three packets split and merged into four buffers" data-canonical-src="http://uml.mvnsearch.org/gist/b31c0bd7bbfc69fd82d6"></p>
<p>Therefore, a receiving part, regardless it is server-side or client-side, should defrag the received data into one or more meaningful frames that could be easily understood by the application logic. In case of the example above, the received data should be framed like the following:</p>
<p><img src="https://camo.githubusercontent.com/6b97e1b759a9389fedfe81112d8bf802f97ffc02e07e5c088f9b069bb2744e21/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262" alt="Four buffers defragged into three" data-canonical-src="http://uml.mvnsearch.org/gist/82e3fbe0e2d4df28322b"></p>
<h4 id="wiki-h4-13">
<a id="user-content-the-first-solution" class="anchor" aria-hidden="true" tabindex="-1" href="#the-first-solution"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The First Solution</h4>
<p>Now let us get back to the <code>TIME</code> client example. We have the same problem here. A 32-bit integer is a very small amount of data, and it is not likely to be fragmented often. However, the problem is that it can be fragmented, and the possibility of fragmentation will increase as the traffic increases.</p>
<p>The simplistic solution is to create an internal cumulative buffer and wait until all 4 bytes are received into the internal buffer. The following is the modified <code>TimeClientHandler</code> implementation that fixes the problem:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.time;

import java.util.Date;

public class TimeClientHandler extends ChannelHandlerAdapter {
    private ByteBuf buf;
    
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        buf = ctx.alloc().buffer(4); // (1)
    }
    
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) {
        buf.release(); // (1)
        buf = null;
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf m = (ByteBuf) msg;
        buf.writeBytes(m); // (2)
        m.release();
        
        if (buf.readableBytes() &gt;= 4) { // (3)
            long currentTimeMillis = (buf.readUnsignedInt() - 2208988800L) * 1000L;
            System.out.println(new Date(currentTimeMillis));
            ctx.close();
        }
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">time</span>;&#x000A;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">Date</span>;&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeClientHandler</span> <span class="pl-k">extends</span> <span class="pl-smi">ChannelHandlerAdapter</span> {&#x000A;    <span class="pl-k">private</span> <span class="pl-smi">ByteBuf</span> <span class="pl-s1">buf</span>;&#x000A;    &#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">handlerAdded</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>) {&#x000A;        <span class="pl-s1">buf</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">buffer</span>(<span class="pl-c1">4</span>); <span class="pl-c">// (1)</span>&#x000A;    }&#x000A;    &#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">handlerRemoved</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>) {&#x000A;        <span class="pl-s1">buf</span>.<span class="pl-en">release</span>(); <span class="pl-c">// (1)</span>&#x000A;        <span class="pl-s1">buf</span> = <span class="pl-c1">null</span>;&#x000A;    }&#x000A;    &#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;        <span class="pl-smi">ByteBuf</span> <span class="pl-s1">m</span> = (<span class="pl-smi">ByteBuf</span>) <span class="pl-s1">msg</span>;&#x000A;        <span class="pl-s1">buf</span>.<span class="pl-en">writeBytes</span>(<span class="pl-s1">m</span>); <span class="pl-c">// (2)</span>&#x000A;        <span class="pl-s1">m</span>.<span class="pl-en">release</span>();&#x000A;        &#x000A;        <span class="pl-k">if</span> (<span class="pl-s1">buf</span>.<span class="pl-en">readableBytes</span>() &gt;= <span class="pl-c1">4</span>) { <span class="pl-c">// (3)</span>&#x000A;            <span class="pl-smi">long</span> <span class="pl-s1">currentTimeMillis</span> = (<span class="pl-s1">buf</span>.<span class="pl-en">readUnsignedInt</span>() - <span class="pl-c1">2208988800L</span>) * <span class="pl-c1">1000L</span>;&#x000A;            <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-k">new</span> <span class="pl-smi">Date</span>(<span class="pl-s1">currentTimeMillis</span>));&#x000A;            <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;        }&#x000A;    }&#x000A;    &#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">exceptionCaught</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Throwable</span> <span class="pl-s1">cause</span>) {&#x000A;        <span class="pl-s1">cause</span>.<span class="pl-en">printStackTrace</span>();&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>A <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> has two life cycle listener methods: <code>handlerAdded()</code> and <code>handlerRemoved()</code>.  You can perform an arbitrary (de)initialization task as long as it does not block for a long time.</li>
<li>First, all received data should be cumulated into <code>buf</code>.</li>
<li>And then, the handler must check if <code>buf</code> has enough data, 4 bytes in this example, and proceed to the actual business logic. Otherwise, Netty will call the <code>channelRead()</code> method again when more data arrives, and eventually all 4 bytes will be cumulated.</li>
</ol>
<h4 id="wiki-h4-14">
<a id="user-content-the-second-solution" class="anchor" aria-hidden="true" tabindex="-1" href="#the-second-solution"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The Second Solution</h4>
<p>Although the first solution has resolved the problem with the <code>TIME</code> client, the modified handler does not look that clean. Imagine a more complicated protocol which is composed of multiple fields such as a variable length field. Your <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> implementation will become unmaintainable very quickly.</p>
<p>As you may have noticed, you can add more than one <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> to a <a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" rel="nofollow"><code>ChannelPipeline</code></a>, and therefore, you can split one monolithic <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> into multiple modular ones to reduce the complexity of your application. For example, you could split <code>TimeClientHandler</code> into two handlers:</p>
<ul>
<li>
<code>TimeDecoder</code> which deals with the fragmentation issue, and</li>
<li>the initial simple version of <code>TimeClientHandler</code>.</li>
</ul>
<p>Fortunately, Netty provides an extensible class which helps you write the first one out of the box:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.time;

public class TimeDecoder extends ByteToMessageDecoder { // (1)
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) { // (2)
        if (in.readableBytes() &lt; 4) {
            return; // (3)
        }
        
        out.add(in.readBytes(4)); // (4)
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">time</span>;&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeDecoder</span> <span class="pl-k">extends</span> <span class="pl-smi">ByteToMessageDecoder</span> { <span class="pl-c">// (1)</span>&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">decode</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">ByteBuf</span> <span class="pl-s1">in</span>, <span class="pl-smi">List</span>&lt;<span class="pl-smi">Object</span>&gt; <span class="pl-s1">out</span>) { <span class="pl-c">// (2)</span>&#x000A;        <span class="pl-k">if</span> (<span class="pl-s1">in</span>.<span class="pl-en">readableBytes</span>() &lt; <span class="pl-c1">4</span>) {&#x000A;            <span class="pl-k">return</span>; <span class="pl-c">// (3)</span>&#x000A;        }&#x000A;        &#x000A;        <span class="pl-s1">out</span>.<span class="pl-en">add</span>(<span class="pl-s1">in</span>.<span class="pl-en">readBytes</span>(<span class="pl-c1">4</span>)); <span class="pl-c">// (4)</span>&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>
<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" rel="nofollow"><code>ByteToMessageDecoder</code></a> is an implementation of <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> which makes it easy to deal with the fragmentation issue.</li>
<li>
<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" rel="nofollow"><code>ByteToMessageDecoder</code></a> calls the <code>decode()</code> method with an internally maintained cumulative buffer whenever new data is received.</li>
<li>
<code>decode()</code> can decide to add nothing to <code>out</code> where there is not enough data in the cumulative buffer.  <a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" rel="nofollow"><code>ByteToMessageDecoder</code></a> will call <code>decode()</code> again when there is more data received.</li>
<li>If <code>decode()</code> adds an object to <code>out</code>, it means the decoder decoded a message successfully.  <a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" rel="nofollow"><code>ByteToMessageDecoder</code></a> will discard the read part of the cumulative buffer.  Please remember that you don't need to decode multiple messages. <a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" rel="nofollow"><code>ByteToMessageDecoder</code></a> will keep calling the <code>decode()</code> method until it adds nothing to <code>out</code>.</li>
</ol>
<p>Now that we have another handler to insert into the <a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" rel="nofollow"><code>ChannelPipeline</code></a>, we should modify the <a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" rel="nofollow"><code>ChannelInitializer</code></a> implementation in the <code>TimeClient</code>:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="b.handler(new ChannelInitializer&lt;SocketChannel&gt;() {
    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new TimeDecoder(), new TimeClientHandler());
    }
});"><pre><span class="pl-s1">b</span>.<span class="pl-en">handler</span>(<span class="pl-k">new</span> <span class="pl-smi">ChannelInitializer</span>&lt;<span class="pl-smi">SocketChannel</span>&gt;() {&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">initChannel</span>(<span class="pl-smi">SocketChannel</span> <span class="pl-s1">ch</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {&#x000A;        <span class="pl-s1">ch</span>.<span class="pl-en">pipeline</span>().<span class="pl-en">addLast</span>(<span class="pl-k">new</span> <span class="pl-smi">TimeDecoder</span>(), <span class="pl-k">new</span> <span class="pl-smi">TimeClientHandler</span>());&#x000A;    }&#x000A;});</pre></div>
<p>If you are an adventurous person, you might want to try the <a href="http://netty.io/5.0/api/io/netty/handler/codec/ReplayingDecoder.html" rel="nofollow"><code>ReplayingDecoder</code></a> which simplifies the decoder even more. You will need to consult the API reference for more information though.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="public class TimeDecoder extends ReplayingDecoder&lt;Void&gt; {
    @Override
    protected void decode(
            ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) {
        out.add(in.readBytes(4));
    }
}"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeDecoder</span> <span class="pl-k">extends</span> <span class="pl-smi">ReplayingDecoder</span>&lt;<span class="pl-smi">Void</span>&gt; {&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">decode</span>(&#x000A;            <span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">ByteBuf</span> <span class="pl-s1">in</span>, <span class="pl-smi">List</span>&lt;<span class="pl-smi">Object</span>&gt; <span class="pl-s1">out</span>) {&#x000A;        <span class="pl-s1">out</span>.<span class="pl-en">add</span>(<span class="pl-s1">in</span>.<span class="pl-en">readBytes</span>(<span class="pl-c1">4</span>));&#x000A;    }&#x000A;}</pre></div>
<p>Additionally, Netty provides out-of-the-box decoders which enables you to implement most protocols very easily and helps you avoid from ending up with a monolithic unmaintainable handler implementation. Please refer to the following packages for more detailed examples:</p>
<ul>
<li>
<a href="http://netty.io/5.0/xref/io/netty/example/factorial/package-summary.html" rel="nofollow"><code>io.netty.example.factorial</code></a> for a binary protocol, and</li>
<li>
<a href="http://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html" rel="nofollow"><code>io.netty.example.telnet</code></a> for a text line-based protocol.</li>
</ul>
<h3 id="wiki-h3-15">
<a id="user-content-speaking-in-pojo-instead-of-bytebuf" class="anchor" aria-hidden="true" tabindex="-1" href="#speaking-in-pojo-instead-of-bytebuf"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Speaking in POJO instead of <code>ByteBuf</code>
</h3>
<p>All the examples we have reviewed so far used a <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a> as a primary data structure of a protocol message. In this section, we will improve the <code>TIME</code> protocol client and server example to use a POJO instead of a <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a>.</p>
<p>The advantage of using a POJO in your <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a>s is obvious; your handler becomes more maintainable and reusable by separating the code which extracts information from <code>ByteBuf</code> out from the handler. In the <code>TIME</code> client and server examples, we read only one 32-bit integer and it is not a major issue to use <code>ByteBuf</code> directly. However, you will find it is necessary to make the separation as you implement a real world protocol.</p>
<p>First, let us define a new type called <code>UnixTime</code>.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.time;

import java.util.Date;

public class UnixTime {

    private final long value;
    
    public UnixTime() {
        this(System.currentTimeMillis() / 1000L + 2208988800L);
    }
    
    public UnixTime(long value) {
        this.value = value;
    }
        
    public long value() {
        return value;
    }
        
    @Override
    public String toString() {
        return new Date((value() - 2208988800L) * 1000L).toString();
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">time</span>;&#x000A;&#x000A;<span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">Date</span>;&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">UnixTime</span> {&#x000A;&#x000A;    <span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">long</span> <span class="pl-s1">value</span>;&#x000A;    &#x000A;    <span class="pl-k">public</span> <span class="pl-smi">UnixTime</span>() {&#x000A;        <span class="pl-smi">this</span>(<span class="pl-smi">System</span>.<span class="pl-en">currentTimeMillis</span>() / <span class="pl-c1">1000L</span> + <span class="pl-c1">2208988800L</span>);&#x000A;    }&#x000A;    &#x000A;    <span class="pl-k">public</span> <span class="pl-smi">UnixTime</span>(<span class="pl-smi">long</span> <span class="pl-s1">value</span>) {&#x000A;        <span class="pl-smi">this</span>.<span class="pl-s1">value</span> = <span class="pl-s1">value</span>;&#x000A;    }&#x000A;        &#x000A;    <span class="pl-k">public</span> <span class="pl-smi">long</span> <span class="pl-en">value</span>() {&#x000A;        <span class="pl-k">return</span> <span class="pl-s1">value</span>;&#x000A;    }&#x000A;        &#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">toString</span>() {&#x000A;        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Date</span>((<span class="pl-en">value</span>() - <span class="pl-c1">2208988800L</span>) * <span class="pl-c1">1000L</span>).<span class="pl-en">toString</span>();&#x000A;    }&#x000A;}</pre></div>
<p>We can now revise the <code>TimeDecoder</code> to produce a <code>UnixTime</code> instead of a <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a>.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@Override
protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) {
    if (in.readableBytes() &lt; 4) {
        return;
    }

    out.add(new UnixTime(in.readUnsignedInt()));
}"><pre><span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;<span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-s1">decode</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">ByteBuf</span> <span class="pl-s1">in</span>, <span class="pl-smi">List</span>&lt;<span class="pl-smi">Object</span>&gt; <span class="pl-s1">out</span>) {&#x000A;    <span class="pl-k">if</span> (<span class="pl-s1">in</span>.<span class="pl-en">readableBytes</span>() &lt; <span class="pl-c1">4</span>) {&#x000A;        <span class="pl-k">return</span>;&#x000A;    }&#x000A;&#x000A;    <span class="pl-s1">out</span>.<span class="pl-en">add</span>(<span class="pl-k">new</span> <span class="pl-smi">UnixTime</span>(<span class="pl-s1">in</span>.<span class="pl-en">readUnsignedInt</span>()));&#x000A;}</pre></div>
<p>With the updated decoder, the <code>TimeClientHandler</code> does not use <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a> anymore:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    UnixTime m = (UnixTime) msg;
    System.out.println(m);
    ctx.close();
}"><pre><span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">channelRead</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>) {&#x000A;    <span class="pl-smi">UnixTime</span> <span class="pl-s1">m</span> = (<span class="pl-smi">UnixTime</span>) <span class="pl-s1">msg</span>;&#x000A;    <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s1">m</span>);&#x000A;    <span class="pl-s1">ctx</span>.<span class="pl-en">close</span>();&#x000A;}</pre></div>
<p>Much simpler and elegant, right? The same technique can be applied on the server side. Let us update the <code>TimeServerHandler</code> first this time:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="@Override
public void channelActive(ChannelHandlerContext ctx) {
    ChannelFuture f = ctx.writeAndFlush(new UnixTime());
    f.addListener(ChannelFutureListener.CLOSE);
}"><pre><span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;<span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-s1">channelActive</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>) {&#x000A;    <span class="pl-smi">ChannelFuture</span> <span class="pl-s1">f</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">writeAndFlush</span>(<span class="pl-k">new</span> <span class="pl-smi">UnixTime</span>());&#x000A;    <span class="pl-s1">f</span>.<span class="pl-en">addListener</span>(<span class="pl-smi">ChannelFutureListener</span>.<span class="pl-c1">CLOSE</span>);&#x000A;}</pre></div>
<p>Now, the only missing piece is an encoder, which is an implementation of <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" rel="nofollow"><code>ChannelHandler</code></a> that translates a <code>UnixTime</code> back into a <a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" rel="nofollow"><code>ByteBuf</code></a>. It's much simpler than writing a decoder because there's no need to deal with packet fragmentation and assembly when encoding a message.</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package io.netty.example.time;

public class TimeEncoder extends ChannelHandlerAdapter {
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
        UnixTime m = (UnixTime) msg;
        ByteBuf encoded = ctx.alloc().buffer(4);
        encoded.writeInt((int) m.value());
        ctx.write(encoded, promise); // (1)
    }
}"><pre><span class="pl-k">package</span> <span class="pl-s1">io</span>.<span class="pl-s1">netty</span>.<span class="pl-s1">example</span>.<span class="pl-s1">time</span>;&#x000A;&#x000A;<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeEncoder</span> <span class="pl-k">extends</span> <span class="pl-smi">ChannelHandlerAdapter</span> {&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">write</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">Object</span> <span class="pl-s1">msg</span>, <span class="pl-smi">ChannelPromise</span> <span class="pl-s1">promise</span>) {&#x000A;        <span class="pl-smi">UnixTime</span> <span class="pl-s1">m</span> = (<span class="pl-smi">UnixTime</span>) <span class="pl-s1">msg</span>;&#x000A;        <span class="pl-smi">ByteBuf</span> <span class="pl-s1">encoded</span> = <span class="pl-s1">ctx</span>.<span class="pl-en">alloc</span>().<span class="pl-en">buffer</span>(<span class="pl-c1">4</span>);&#x000A;        <span class="pl-s1">encoded</span>.<span class="pl-en">writeInt</span>((<span class="pl-smi">int</span>) <span class="pl-s1">m</span>.<span class="pl-en">value</span>());&#x000A;        <span class="pl-s1">ctx</span>.<span class="pl-en">write</span>(<span class="pl-s1">encoded</span>, <span class="pl-s1">promise</span>); <span class="pl-c">// (1)</span>&#x000A;    }&#x000A;}</pre></div>
<ol>
<li>
<p>There are a few important things to notice in this handler method:</p>
<p>First, we pass the original <a href="http://netty.io/5.0/api/io/netty/channel/ChannelPromise.html" rel="nofollow"><code>ChannelPromise</code></a> as-is so that Netty marks it as success or failure when the encoded data is actually written out to the wire.</p>
<p>Second, we did not call <code>ctx.flush()</code>.  There is a separate handler method <code>void flush(ChannelHandlerContext ctx)</code> which is purposed to override the <code>flush()</code> operation.</p>
</li>
</ol>
<p>To simplify even further, you can make use of <a href="http://netty.io/5.0/api/io/netty/handler/codec/MessageToByteEncoder.html" rel="nofollow"><code>MessageToByteEncoder</code></a>:</p>
<div class="highlight highlight-source-java notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="public class TimeEncoder extends MessageToByteEncoder&lt;UnixTime&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, UnixTime msg, ByteBuf out) {
        out.writeInt((int) msg.value());
    }
}
"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TimeEncoder</span> <span class="pl-k">extends</span> <span class="pl-smi">MessageToByteEncoder</span>&lt;<span class="pl-smi">UnixTime</span>&gt; {&#x000A;    <span class="pl-c1">@</span><span class="pl-c1">Override</span>&#x000A;    <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">encode</span>(<span class="pl-smi">ChannelHandlerContext</span> <span class="pl-s1">ctx</span>, <span class="pl-smi">UnixTime</span> <span class="pl-s1">msg</span>, <span class="pl-smi">ByteBuf</span> <span class="pl-s1">out</span>) {&#x000A;        <span class="pl-s1">out</span>.<span class="pl-en">writeInt</span>((<span class="pl-smi">int</span>) <span class="pl-s1">msg</span>.<span class="pl-en">value</span>());&#x000A;    }&#x000A;}</pre></div>
<p>The last task left is to insert a <code>TimeEncoder</code> into the <a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" rel="nofollow"><code>ChannelPipeline</code></a> on the server side before the <code>TimeServerHandler</code>, and it is left as a trivial exercise.</p>
<h3 id="wiki-h3-16">
<a id="user-content-shutting-down-your-application" class="anchor" aria-hidden="true" tabindex="-1" href="#shutting-down-your-application"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Shutting Down Your Application</h3>
<p>Shutting down a Netty application is usually as simple as shutting down all <a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" rel="nofollow"><code>EventLoopGroup</code></a>s you created via <code>shutdownGracefully()</code>.  It returns a <a href="http://netty.io/5.0/api/io/netty/util/concurrent/Future.html" rel="nofollow"><code>Future</code></a> that notifies you when the <a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" rel="nofollow"><code>EventLoopGroup</code></a> has been terminated completely and all <a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" rel="nofollow"><code>Channel</code></a>s that belong to the group have been closed.</p>
<h3 id="wiki-h3-17">
<a id="user-content-summary" class="anchor" aria-hidden="true" tabindex="-1" href="#summary"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Summary</h3>
<p>In this chapter, we had a quick tour of Netty with a demonstration on how to write a fully working network application on top of Netty.</p>
<p>There is more detailed information about Netty in the upcoming chapters. We also encourage you to review the Netty examples in the <a href="https://github.com/netty/netty/tree/master/example/src/main/java/io/netty/example"><code>io.netty.example</code></a> package.</p>
<p>Please also note that <a href="http://netty.io/community.html" rel="nofollow">the community</a> is always waiting for your questions and ideas to help you and keep improving Netty and its documentation based on your feed back.</p>

              </div>

              <div id="wiki-footer" class="mt-5 Link--muted wiki-footer">
                <a class="d-block p-3 Link--muted text-center border border-dashed rounded-2" href="_new?wiki%5bname%5d=_footer.html">
                  <svg aria-hidden="true" height="16" viewbox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-plus mr-1">
    <path d="M7.75 2a.75.75 0 0 1 .75.75V7h4.25a.75.75 0 0 1 0 1.5H8.5v4.25a.75.75 0 0 1-1.5 0V8.5H2.75a.75.75 0 0 1 0-1.5H7V2.75A.75.75 0 0 1 7.75 2Z"></path>
</svg> Add a custom footer
</a>              </div>
          </div></div>
<div class="toc-container col-md-3 hidden-xs hidden-sm hidden-print" role="complementary">
<div class="toc well">
<ul class="nav nav-list nav-stacked">
<li class="nav-header">Table of Contents
</li><li>
<ul class="nav nav-list nav-stacked"><li><a href="#wiki-h3-0" title="3rd-party translations">3rd-party translations</a>
</li></ul></li><li><a href="#wiki-h2-1" title="Preface">Preface</a>
<ul class="nav nav-list nav-stacked"><li><a href="#wiki-h3-2" title="The Problem">The Problem</a>
</li></ul></li><li><a href="#wiki-h2-3" title="The Solution">The Solution</a>
</li><li><a href="#wiki-h2-4" title="Getting Started">Getting Started</a>
<ul class="nav nav-list nav-stacked"><li><a href="#wiki-h3-5" title="Before Getting Started">Before Getting Started</a>
</li><li><a href="#wiki-h3-6" title="Writing a Discard Server">Writing a Discard Server</a>
</li><li><a href="#wiki-h3-7" title="Looking into the Received Data">Looking into the Received Data</a>
</li><li><a href="#wiki-h3-8" title="Writing an Echo Server">Writing an Echo Server</a>
</li><li><a href="#wiki-h3-9" title="Writing a Time Server">Writing a Time Server</a>
</li><li><a href="#wiki-h3-10" title="Writing a Time Client">Writing a Time Client</a>
</li><li><a href="#wiki-h3-11" title="Dealing with a Stream-based Transport">Dealing with a Stream-based Transport</a>
<ul class="nav nav-list nav-stacked"><li><a href="#wiki-h4-12" title="One Small Caveat of Socket Buffer">One Small Caveat of Socket Buffer</a>
</li><li><a href="#wiki-h4-13" title="The First Solution">The First Solution</a>
</li><li><a href="#wiki-h4-14" title="The Second Solution">The Second Solution</a>
</li></ul></li><li><a href="#wiki-h3-15" title="Speaking in POJO instead of ByteBuf">Speaking in POJO instead of ByteBuf</a>
</li><li><a href="#wiki-h3-16" title="Shutting Down Your Application">Shutting Down Your Application</a>
</li><li><a href="#wiki-h3-17" title="Summary">Summary</a>
</li><li><a href="#wiki-h3-18" title="Toggle tagle of contents

      Pages 30">Toggle tagle of contents

      Pages 30</a>
</li></ul>
</li></ul>
</div>
</div>
</div>

<div class="row">
<div class="col-md-9">
<div class="text-right">
<small>Last retrieved on 23-Jan-2024</small>
</div>
</div>
</div>
</div>

</div>

</div>
<div class="container">
<hr>
<div id="footer">
<p>
Copyright &copy; 2024
<a href="../index.html">The Netty project</a>
</p>
</div>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js" type="text/javascript"></script>
<script src="../lib/common.footer.js" type="text/javascript"></script>

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-95307-5', 'auto');
ga('require', 'displayfeatures');
ga('require', 'linkid', 'linkid.js');
ga('send', 'pageview');
</script>
</body>
</html>
